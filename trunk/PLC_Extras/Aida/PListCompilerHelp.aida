!! !! ===========================================================================
!! !! PListCompilerHelp.aida
!! !!                       Created: 2005-10-03 16:27:26
!! !!             Last modification: 2005-11-03 07:50:32
!! !! Author: Bernard Desgraupes
!! !! e-mail: <bdesgraupes@easyconnect.fr>
!! !! www: <http://webperso.easyconnect.fr/bdesgraupes/>
!! !! © Copyright: Bernard Desgraupes 2003-2005
!! !! All rights reserved.
!! !! $Date$
!! !! $Revision$
!! !! ===========================================================================

:Title:       PListCompilerHelp
:DestFolder:  ../../PLC_Help
:Author:      Bernard DESGRAUPES <bdesgraupes@easyconnect.fr>
:Homepage:    <http://webperso.easyconnect.fr/bdesgraupes/>
:Created:     2005-10-03 16:27:26
:Modified:    2005-11-03 07:50:32
:Keywords:    property list, xcode, compiler
:Source:      PlcAidaMacros.tcl


((/
((b PList Compiler b)) is a property list compiler for XCode. 
It is developed as an ((i Open Source i)) project coming with a BSD
License. The source code is currently hosted and developed on the 
((lk http://sourceforge.net/projects/plistcompiler ))SourceForge site. lk))
((nl This file documents version ((s [plc::getVersion] s)) of PList Compiler.
/))

((toc

((s1 Introduction


((b PList Compiler b)) is a property list compiler for XCode. It lets you build
localized and non-localized plist files from plc and ploc source files. 
These are the property list files found in packages applications, bundles, 
frameworks, plugins, etc.


It is modelled on the CodeWarrior property list language: the idea of
preparing source files and compiling them during the build process was
introduced in CodeWarrior Pro 8. The language used in these source files
lets you have the compiler build the property list files for you
automatically, substituting the right values during the building process,
instead of having to manage manually hard-coded XML files. CodeWarrior Pro 
8 introduced a first draft of the plc language together with a dedicated 
compiler written by Josef W. Wankerl. Unfortunately XCode does not offer 
such a handy tool. Here comes ((b PList Compiler b))!

It is a shell script, named ((b plcompile b)), which is meant to be executed during a Shell Script
Build Phase within an XCode project. It can also be run directly as a
command line tool if you need to work only with plc files independently 
from the rest of your project.

((b PList Compiler b)) uses the same syntax as the original CodeWarrior 
compiler it supports most of its functionalities and adds many more to take 
advantage of all the XCode settings.

((b PList Compiler b)) is written in fact in ((b Tcl b)) 
(the ((lk http://wiki.tcl.tk/ )) Tool Command Language lk))): 
the executable script is a ((i bash i)) script called ((b plcompile b)) which magically redirects the
instructions to ((i tclsh i)) which is the Tcl shell. Tcl is installed by
default on OSX since version 10.3 (aka Panther) so ((i tclsh i)) is
normally present on every MacOSX system starting from this version, and 
there should be nothing special to do for this script to run there. For
version 10.2 systems (aka Jaguar), you will have to install Tcl on your
machine: you can, for instance, get Daniel Steffen's Tcl Batteries Included distribution 
((lk http://www.maths.mq.edu.au/~steffen/tcltk/ )) from there. lk))

((b PList Compiler b)) comes with the same BSD license as Tcl itself. 
See the file ((i License_terms i)) included in this distribution or the 
((lk http://www.opensource.org/licenses/bsd-license )) Open Source Initiative (OSI) site lk)).


((s1 Usage

The syntax of the ((b plcompile b)) shell script is:
((|
    plcompile options plcFile
    plcompile (-help | -encoding | -version)
|))

The first form executes the compilation of the plc source file ((i plcFile i)). 
Traditionnally these files have a ((i .plc i)) extension but this is not 
required at all. Most of the time you will not have to worry about the 
options. ((b PList Compiler b)) comes with reasonable defaults for the 
optional values, corresponding to a normal usage of these files in a 
project. The available options are explained below.

In the second form
((|
	plcompile -help
	plcompile -encoding
	plcompile -version
|))
the script prints some help in the console window: with ((i -help i)), you
get the usage string and a reminder of the defaults; with ((i -encoding i)), 
you get a list of the available encodings; with ((i -version i)), you get
the current version number of the script. Note that one can use 
abbreviated flags like ((i -h i)) or ((i -v i)) 
for instance.


((s2 Default behavior
By default, ((b plcompile b)) assumes that the input files are encoded in
MacRoman and have Mac line endings (((i cr i))). The same type of line
endings is used to write the output files but the encoding, this time, is the
Unicode utf-8 form. 

The default destination folder depends on how you execute the compiler:
((lu
((li if you run the script from XCode as a ((i Shell Script phase i)) (this
is the recommended way), the destination folder depends on the kind of
product you are building: it is the ((i Contents i)) folder inside the
application bundle when you are building a packaged application; in the
case of a framework, it is the ((i Resources i)) subfolder of the
frapmework ;
((li otherwise it is the same folder as the plc file being processed.
lu))


These are default behaviors which can be modified with options on the 
command line or pragmas in the source files. See the
((rf locout )) Location of the output files rf)) section below.


((s2 Command line options

The complete syntax to run the compiler is:
((|
    plcompile [-input_encoding enc] [-output_encoding enc] [-input_eol eol] 
                            [-output_eol eol] [-dest folder] [-plist version] plcFile
|))

The options have the following meaning:
((lu
((li the ((i -input_encoding i)) option lets you specify in which encoding the 
source file should be read (by default ((i macRoman i)));
((li the ((i -output_encoding i)) option  lets you specify in which encoding the 
output files should be written (by default ((i utf-8 i)));
((li the ((i -input_eol i)) option lets you specify the type of line endings used in the
source file (((i cr i)) for Mac, ((i lf i)) for Unix and ((i crlf i)) for Windows);
((li the ((i -output_eol i)) option lets you specify the type of line endings used in
the output files;
((li the ((i -dest i)) option lets you specify a destination folder relatively to which
the output files will be produced. See the
((rf locout )) Location of the output files rf)) section below. Various
pragmas can also be used to specify different subfolders inside the
destination folder.
((li the ((i -plist i)) option lets you specify the version of the plist XML format (0.9 
or 1.0). The default value is 1.0.
lu))

((s1 Howto

((s2 Using PList Compiler in an XCode project

The idea is to generate the various plist files and localized strings
files during a ((i Shell Script Build Phase i)) within your XCode project. 
XCode lets you define ((i Shell Script Build Phases i)): they are shell
scripts which can be executed at any stage of the building process. 

So, in order to use ((b PList Compiler b)) from XCode, you would normally create, in
all the targets for which you want plist files to be generated, a build phase
which could take place at the end of the build process. To create a 
((i Shell Script Build Phase i)), select the target you want in the ((i Groups
and Files i)) panel of your main project window and select the ((i Shell
Script Build Phase i)) command in the ((i New Build Phase i)) submenu of
the ((i Project i)) menu. If you open the disclosure triangle located in 
front of the target's name, you will see your new shell phase (in XCode 2.1, 
it is called ((i Run Script i))). Select it and click on the ((i Info i)) button 
in the toolbar (or select ((i Get Info i)) in the ((i File i)) menu).

XCode displays a window in which you can enter shell commands to execute. 
If your plc file is named MyApp.plc, you should just have to enter a 
command like
((|
    plcompile /path/to/MyApp.plc
|))
The only point is to make sure that the shell (Bash shell) can find the 
((b plcompile b)) script. This depends on where you have put this script on your 
machine. If it is in one of the folders of your shell ((v PATH v)) 
variable, there should be no problem. Otherwise you can specify the
complete path of the script, like for instance:
((|
        /Users/bernardo/Devel/Tools/plcompile   /path/to/MyApp.plc
|))
or alternatively change the directory to this directory and execute the 
script there, like this:
((|
        cd /Users/bernardo/Devel/Tools
        ./plcompile  /path/to/MyApp.plc
|))
supposing, in the previous example, that ((b plcompile b)) resides in ((i /Users/bernardo/Devel/Tools i)).


((s2 Using PList Compiler in Terminal

The ((i plcompile i)) script can be used directly from the command line (in
a Terminal window). There is only one caveat with this approach: only the
environment variables defined in the current shell window are available.
This means that you must make sure, if ever your plc file makes use of
environment variables defined by XCode, that they are available in the
shell. You could have to define them manually. If your plc file does not
need any of the values set by XCode, then you should normally be able to
compile your plc files directly. You will probably want, in that case, to
specify a destination folder using the ((i -dest i)) command line option.

For instance:
((|
    /Developer/Tools/plcompile -dest ~/Devel/Tests myfile.plc
|))


((s2 Troubleshooting

In case the instructions above do not work as expected, here are a few 
indications to help solving the problem.
 
Make sure that the plcompile script has been saved with Unix line endings
(lf) rather than Mac line endings (cr). Some editors tend to change them 
in your back and the shell expects Unix line endings.

Make sure there is not an already existing ((i Info.plist i)) file in your source 
files added to your built product during the ((i Copy Bundle Resources i)) 
phase in order to avoid conflicts or files being overwritten.

Make sure, in the target settings, that no file has been declared in 
the ((i Info.plist File i)) setting (look in the ((i Packaging i)) section of the 
((i General i)) settings).

Make sure of course that Tcl is installed on your machine. It is part of 
the Panther and Tiger installation.

If you are having trouble with the encodings, it is maybe because the text 
editor you used to create the ((i .plc i)) source files saved your files in 
utf-8. If your source file is utf-8 encoded, you will have to tell 
((b plcompile b)) and specify the ((i -input_encoding i)) option, like this:
((|
    ./plcompile -input_encoding utf-8 /path/to/MyApp.plc
|))
Once again, the default is to read the source files in macRoman and to
write the output files in utf-8.

Make sure you used the proper casing to specify the encodings: it is ((i
macRoman i)) and not ((i MacRoman i)), ((i utf-8 i)) and not ((i UTF-8 i)).
If you have a doubt, execute the following command which returns the list
of all the available encodings:
((|
    plcompile -encoding
|))

If the script is not found by the shell, read the informations in the 
section above about executing shell phases in XCode and setting the access 
paths correctly.


((s1 Anatomy of 'plc' files

The ((i .plc i)) source files are regular text files taken as input by
((b PList Compiler b)) in order to produce one or several output files.
They contain three types of commands:
((lu
((li preprocessor macros, simlar to those found in C or C++ source files;
((li specific commands understood and interpreted by the compiler;
((li comments ignored by the compiler.
lu))


((s2 Comments

((b PList Compiler b)) recognizes two kinds of comments: the C-like
comments enclosed between /* and */ which can span multiple lines, and, on
a single line, portions of text starting with a double slash (//) up to the
end of the line. Be careful with the latter because, as of this version,
the compiler is not clever enough to detect comment symbols included in a
quoted string and which you would not like to be considered as a comment.


((s2 The plc commands

Most of these commands correspond to an XML entity in the output ((i Info.plist i))
file. An ((i Info.plist i)) file is an XML document. The format of the plist files
is specified by Apple in a DTD which can be found in 
((i /System/Library/DTDs/PropertyList.dtd i)).
For a detailed description of property lists files, see for instance
((lk http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFPropertyLists/index.html )) Introduction to Property Lists lk))

All the commands must be kept on a separate line (but not necessarily at the 
beginning of the line).

((s3 The 'plist' command

The first command found in a ((i .plc i)) file designed to generate a .plist file
is always the ((i plist i)) command. Its argument is a block enclosed
inside a pair of curly braces. A minimal property list file,
describing a completely empty property list, would look like this:
((|
    plist {}
|))

The ((i plist i)) command corresponds to the <plist> XML tag.


((s3 The 'dictionary' command

Directly inside the ((i plist i)) block, there is usually a ((i dictionary i)) 
command. This is not required by the DTD but all property lists in use are
structured like this. Like with the ((i plist i)) command, the argument of a
((i dictionary i)) command is a block enclosed inside a pair of curly
braces. So, a minimal valid plc source file would be:
((|
    plist
    {
        dictionary {}
    }
|))

The ((i dictionary i)) command corresponds to the <dict> XML tag.

The dictionary is made up of key/value pairs. The key names must be unique within a single
dictionary. The value of a key can have any of the following types: ((i array, boolean,
data, date, dictionary, number, i)) or ((i string i)).


((s3 The 'key' command

The key/value pairs are declared by instructions in the following format
((|
    key "name_of_the_key" value "type_of_value" "the_value"
|))

In this instruction, the ((i key i)) and  ((i value i)) keywords correspond
to the <key> and <value>  XML tags respectively.

For instance, here is a valid key statement in a dictionary block:
((|
    key "Victor Hugo" value string "Writer"
|))


((s3 The 'array' command

The ((i array i)) command is used to describe an ordered list of property list elements.
These elements can be of any of the abovementioned types ((i (array, boolean,
data, date, dictionary, number, string). i))

The original specification of the plc syntax in CodeWarrior stipulated that
the argument of an ((i array i)) command is a block enclosed inside a pair
of square brackets. With ((b PList Compiler b)), you can also use curly braces
instead of square brackets.

Here is an example of an array containing a dictionary and a boolean value:
((|
    array
    {
        boolean true
        dictionary {
            key "Victor Hugo" value string "Writer"
            key "Ludwig van Beethoven" value string "Composer"
        }
    }
|))


((s3 The 'string' command

The ((i string i)) command lets you specify a string value. Strings are
enclosed in double quotes in order to distinguish them
from a substitutable variable (see below), but this is not required. If
there is no risk of ambiguity, you can suppress the quotes. Still it
is good programming practice to write them.

The value of a string can be made up of several pieces, mixing quoted strings or 
variables. For instance:
((|
    string "copyright (c) " __YEAR__ ", all rights reserved" 
|))
where ((v __YEAR__ v)) is one of the predefined variables set by the 
compiler. This string will be expanded to something like 
((i copyright (c) 2005, all rights reserved i)).
The ((i string i)) command corresponds to the <string> XML tag.

((b Caveat: b)) in order to ensure a better compatibility with the
CodeWarrior property list compiler which accepted both ((i single i)) and
((i double i)) quotes to delimit strings, PList Compiler does its best to
support the same convention. For instance:
((|
	string 'RSRC'
|))
will produce ((i <string>RSRC</string> i)) as it did with the CodeWarrior
property list compiler. As a consequence, this makes it a little more
difficult to obtain values enclosed in quotes in the output file. For
instance, if you really want to get a string value like 'RSRC' or "RSRC"
(including the quotes), you will have to code it like this:
((|
	string "'RSRC'"
	string "\"" RSRC "\""
|))
Be also aware that, in the case where you concatenate several strings or
mix strings and variables, single quotes will confuse the compiler and the
odds are very high that you won't obtain what you expect, so your best bet
is to always use double quotes (and no quotes at all for substitutable
variables).

!! !! Similarly, whitespace characters must be escaped. If you write 
!! !! ((|
!! !! 	string 'TCL '
!! !! |))
!! !! you will get ((i <string>'TCL'</string> i)) (with single quotes and no
!! !! whitespace!) which is probably not what you want. This is because, in that 
!! !! example, the compiler sees two unquoted strings: the first is ((i 'TCL i))
!! !! and the second is an isolated single quote. In order to get 
!! !! ((i <string>TCL </string> i)), you must write:
!! !! ((|
!! !! 	string 'TCL\ '
!! !! |))

((s3 The 'number' command

The ((i number i)) command lets you specify numeric values. There is no 
XML tag named ((i number i)) in a plist file, but rather two entities named 
<real> and <integer> corresponding 
respectively to integer or floating point values. The ((i number i)) 
command corresponds to both of them: the compiler automatically decides to 
which type the value belongs. For instance, the following declarations will 
result in an <integer> tag:
((|
    number 0
    number 1
    number -1
|))
while the following ones will yield <real> tags:
((|
    number 0.0
    number 3.14
    number -2.718
    number .1
    number -.1
    number 6.09e23
|))


((s3 The 'date' command

The ((i date i)) command lets you specify a date value. The plist format 
specification (in ((i /System/Library/DTDs/PropertyList.dtd i))) suggests that 
((q the 
contents of a date value should conform to a subset of ISO 8601:
in particular, YYYY '-' MM '-' DD 'T' HH ':' MM ':' SS 'Z'. 
Smaller units may be omitted with a loss of precision.
q))

For instance:
((|
    date "2005-09-15 18:06:03"
    date "2005-09-15T18:06:03Z"
    date __DATE__
|))
where ((v __DATE__ v)) is one of the predefined variables set by the compiler.
The ((i date i)) command corresponds to the <date> XML tag.


((s3 The 'data' command

The ((i data i)) command is used to store raw binary data. The value of a
data type is expressed in the plc file in hexadecimal format, possibly with
space characters, like for instance:
((|
    data "64656667"
    data "64 65 66 67"
    data "64 65"  "66 67"
|))
In the output file, the same data is represented in Base64 encoding as 
recommended in the DTD specifying the plist format 
(see ((i /System/Library/DTDs/PropertyList.dtd i))). All the 
values above are equivalent and are represented like this in Base64 
encoding:
((nl <data>ZGVmZw==</data>

The ((i data i)) command corresponds to the <data> XML tag.

((b Note: b)) the CodeWarrior plist compiler also defined a ((i data file
i)) command followed by the name of a file containing raw data. This is not
implemented by ((b PList Compiler b)) as of version 0.1.



((s3 The 'boolean' command

The ((i boolean i)) command lets you specify a boolean value using any of
the usual keywords: true/false, yes/no, and 1/0. Casing does not matter, so
TRUE, true or True are all acceptable values. The value can be enclosed in
double quotes but this is not required.

For example:
((|
    key "kGcc_Precompile_Prefix_Header" value boolean 1
    key "kGcc_Symbols_Private_Extern" value boolean 0
    key "kGenerate_Profiling_Code" value boolean Yes
    key "kUse_Dynamic_No_Pic" value boolean "false"
    key "kZero_Link" value string __ZERO_LINK__
|))

The last example is correct because XCode defines a ZERO_LINK variable 
whose value can be either "YES" or "NO" (see below).

The ((i boolean i)) command corresponds to the <boolean> XML tag.


((s2 Localized files

The localized files contain lists of keyed strings localized for a particular 
language.

((s3 The 'localize' command

The ((i localize i)) command is used to create and generate localized strings files. It is a 
top level command like the ((i plist i)) command. There are two possible 
syntaxes to invoke this command:
((|
    localize "language"
    localize "language" as "localized_file_name"
|))

The first form is used to localize string values present in the main property list
dictionary of the ((i plist i)) command. The resulting file is named by 
default
((i InfoPlist.strings i)) instead of ((i Info.plist i)), and is located inside the 
localized folder corresponding to the specified language instead of the 
((i Contents i)) folder. For instance:
((|
    /Contents/Resources/Spanish.lproj/InfoPlist.strings
|))

The second form of the ((i localize i)) command specifies the name of the generated
file rather than relying on the default name. This allows to create several
separate strings files. These files will also be created in
the folder corresponding to the specified language.

The argument of the ((i localize i)) command is a block enclosed in a pair of 
curly braces. Only two commands can be used inside a localize block: ((i key i)) 
and ((i comment i)). The ((i key i)) command defines key/value statements of type ((i string i)). 
For instance:
((|
    localize "French"
    {
        key "CFBundleGetInfoString" value string "MyApp, (c) 2005, tous droits rservs"
        key "CFBundleHelpBookName" value string "Aide PList Compiler"
    }
    
    localize "Spanish" as "Dialogs.strings"
    {
        key "Number of Recent Items:" value string "Nmero de tems recientes:"
        key "General Preference Pane" value string "Panel de preferencias General"
    }
|))
The first instruction generates 
((i MyApp.app/Contents/Resources/French.lproj/InfoPlist.strings i))
and the scond one
((i MyApp.app/Contents/Resources/Spanish.lproj/Dialogs.strings i))

It is current practice to put the ((i localize i)) blocks in separate files and 
use a ((i .ploc i)) extension in their name to distinguish them from the ((i .plc i)) 
files. The ((i .ploc i)) files are usually invoked from the main ((i .plc i)) file with an 
((v #include v)) preprocessor command. For instance:
((|
    #include "DialogStrings_Spanish.ploc"
|))


((s3 The 'comment' command

The ((i comment i)) command lets you insert comments inside the localized
strings files. There can be as many commands of this type in a ((i localize
i)) block as necessary. The value of the command is a string or
concatenation of strings and expandable variables: once concatenated and
substituted, it is inserted inside a C-like comment of the form 
((v /* */ v)) in the output file.
For instance, the following instruction might be found in some ((i .ploc
i)) file:
((|
    localize "English" as "Dialogs.strings"
    {
        comment "Generated from " __FILE__ " at " __TIME__
    }
|))

The ((v __FILE__ v)) and the ((v __TIME__ v)) symbols used in this example are predefined variables: ((v __FILE__ v)) 
always contains the name of the file being currently processed by the 
compiler and ((v __TIME__ v)) the time at the moment the compiler processes the 
file. If the instruction above was stored in a file named 
((i dialogStrings_EN.ploc i)), the comment generated in the resulting ((i 
Dialogs.strings i)) file (in the /Contents/Resources/English.lproj 
folder inside the bundle) would look like this:
((|
    /* Generated from dialogStrings_EN.ploc at 23:54:25 */
|))

((b Caveat: b)) the ((i comment i)) command can't be used in a ((i plist i)) block.

((a locout )) a))
((s1 Location of the output files

By default, the ((i plist i)) command causes ((b PList Compiler b)) to
create a file named ((i Info.plist i)) inside the destination directory. In the
case of a packaged application, the default destination directory is the
((i Contents i)) folder inside the bundle. More generally, the path of this
destination folder is built by ((b PList Compiler b)) using the values of
the ((v BUILT_PRODUCTS_DIR v)) and ((v INFOPLIST_PATH v)) XCode
variables. 

For instance, with XCode 2.1, if your target is in the ((i Release i))
configuration and your application is MyApp, the destination folder would
be (unless you have non standard settings):
((|
    $SRCROOT/build/Release/MyApp.app/Contents 
|))
where ((v SRCROOT v)) is, as usual the folder containing your project file.

By default, the ((i localize i)) command causes ((b PList Compiler b)) to
create localized files. The default location for these files depends on the
language used for the localization. In the case of a packaged application,
the default destination is inside one of the ((i /Contents/Resources/<language>.lproj i))
subfolders of the bundle. For instance ((i /Contents/Resources/English.lproj i)) or
((i /Contents/Resources/French.lproj i)).

There are two ways of modifying the destination folders:
((lu
((li from the command line, using the ((i -dest i)) option
((li using one of the ((i in_package_directory i)) or ((i localize_directory i)) pragmas (see below)
lu))

The output file name (usually Info.plist) can be modified using the
((i output_filename i)) pragma. See the ((i Pragmas i)) section below.


((s1 Preprocessor directives

This is the other type of instruction found in plc source files. They are called preprocessor directives 
by analogy with the C/C++ language.
They are also sometimes refered to as preprocessor macros. The 
preprocessor term is not quite accurate here 
because there are not two phases like with the ordinary C compilers (a 
preprocessing phase and a compiling phase): ((b PList Compiler b)) parses 
the file once, line by line.

The following macros are supported by ((b PList Compiler b)):
((t0
((tr #define 	#message	#if    	#elif 
((tr #include	#warning	#ifdef 	#else 
((tr #pragma 	#error  	#ifndef	#endif
t))


Preprocessor directives all occur on their own line. They are characterized
by the fact that the first non-whitespace character on the line is a #. 
There may be whitespace characters between the # mark and the name of the 
directive too.

((s2 Defines
The ((i #define i)) directive lets you define a macro in the property list compiler.  The
format is:
((|
    #define macro_name macro_text
|))

The compiler adds the macro ((i macro_name i)) to its macro table: if 
there is already a macro with this name, it emits an error. When ((i macro_name i))
appears in a plc source file as the value of a string type not 
enclosed between double quotes, it is automatically replaced by
((i macro_text i)).

For instance, if a macro ((i kVersionNumber i)) is defined like this:
((|
    #define kVersionNumber "1.2.3"
|))
then, when the compiler encounters the following instruction:
((|
    key "CFBundleShortVersionString" value string "kVersionNumber: " kVersionNumber
|))
it expands it to ((i kVersionNumber: 1.2.3 i))

The ((i #undef i)) directive tells the compiler to remove an already 
existing macro from its macro table. The syntax is:
((|
    #undef macro_name
|))
If ((i macro_name i)) does not exist, the directive is just ignored.

((b Note: b)) the same remarks as with the ((i string i)) keyword apply
here concerning the use of single quotes as string delimiters. They are
supported in the case of simple string values but not in concatenations.
Use double quotes to be safe.

((s2 Includes
The ((i #include i)) directive tells the plist compiler to find another 
plc source
file and start processing it. The format of this directive is:
((|
    #include "filename"
|))

The ((i filename i)) value designates a file to include: it can be either 
an absolute or a relative path. A relative path is resolved relatively to the folder 
containing the plc source file itself. The following are all valid 
examples:
((|
    #include /Users/bernardo/Devel/MyApp/Rsrc/OtherFile.plc
    #include OtherFile.plc
    #include LocFiles/MyStrings_EN.ploc
    #include ../Rsrc/MyStrings_EN.ploc
|))

((b Note: b)) the CodeWarrior property list compiler also accepts filenames 
enclosed in angle brackets to designate files located in the system access 
paths. This is not currently supported by ((b PList Compiler b)) as of version 0.1.


((s2 Conditional macros

((b PList Compiler b)) supports the following six conditional directives:
((i ((i #if i)), ((i #ifdef i)), ((i #ifndef i)), ((i #elif i)), ((i #else i)), ((i #endif i)) i)) which let you build
conditional blocks of instructions depending on the value of a test
expression or on the existence or non-existence of a particular variable.

The ((i #ifdef i)) directive tests for the definition of a compiler macro, while
the ((i #ifndef i)) directive tests for the non-definition of this macro. Their
behavior is the opposite of one another. In the case of ((i #ifdef i)) for
instance, if the macro has been previously defined, the property list code
immediately following the ((i #ifdef i)) directive is processed until an ((i #else i)) or
((i #endif i)) directive is encountered, but on the contrary, if the macro has not been defined,
the property list code immediately following the ((i #ifdef i)) directive is not
processed. In that case, if there is an ((i #else i)) directive, instead the code
following this ((i #else i)) is processed until the matching ((i #endif i)) directive is
found.

Similarly, if the expression in an ((i #if i)) directive evaluates to 1, the
instructions immediately following the ((i #if i)) directive are executed until an
((i #else i)), ((i #elif i)), or ((i #endif i)) directive is encountered. If the expression
evaluates to 0, the property list code immediately following the ((i #if i))
directive is not processed.

Each ((i #if i)), ((i #ifdef i)), ((i #ifndef i)) directive must be matched by an ((i #endif i)) directive.

The ((i #elif i)) directive allows for multiple successive ((i #if i)) tests during the
preprocessing stage. An ((i #elif i)) test is evaluated only if all the preceding
tests have failed.

Here are a few examples of conditional constructs.

((s3 Example 1
Note in this example that for testing equality you must use a double 
equal sign (==). A single equal sign would provoke an error.
((|
    #define kVersionFive 5
    #define kVersionSeven 7
    #define kCurrentVersion kVersionFive
    
    #if kCurrentVersion == kVersionSeven 
        #warning "Current version is " kVersionSeven
    #else
        #warning "Current version is not " kVersionSeven    
    #endif
|))

((s3 Example 2
This example demonstrates nested conditional blocks.
((|
    #define kVersionFive 5
    #define kVersionSix 6
    #define kVersionSeven 7
    #define kCurrentVersion kVersionSeven
    
    #if kCurrentVersion == kVersionSeven 
        #warning "Current version is " kVersionSeven
    #else
        #if kCurrentVersion <= kVersionFive 
            #warning "Current version <= " kVersionFive
        #else
            #warning "Current version > " kVersionFive
        #endif
        #warning "Done comparison with kVersionFive"
    #endif
|))


((s3 Example 3
Here is an example using ((i #ifdef i)) and ((i #ifndef i)) directives:
((|
    #undef kUndefinedMacro
    #ifdef kUndefinedMacro
    #    define kWillNeverBeDefinedMacro
    #endif
    
    #ifndef kWillNeverBeDefinedMacro
    #    define kHasNotBeenDefined "No, it has not been defined"
    #else
    #    define kHasBeenDefined "Yes, it has been defined"
    #endif
|))


((s3 Example 4
Here is an example using the ((i #elif i)) directive:
((|
    #define kVersionFive 5
    #define kVersionSix 6
    #define kVersionSeven 7
    #define kVersionEight 8
    #define kCurrentVersion kVersionSix
    #if kCurrentVersion <= kVersionFive 
    #warning "Current version is <= " kVersionFive
    #elif kCurrentVersion <= kVersionEight 
        #if kCurrentVersion == kVersionSix
            #warning "Current version is " kVersionSix
        #elif kCurrentVersion == kVersionSeven 
            #if kCurrentVersion < 0
                #warning "Current version is negative!"
            #elif kCurrentVersion > 10
                #warning "Current version is > 10"
            #else
                #warning "Current version is between 1 and 10"
            #endif
        #else
            #warning "Current version is " kVersionEight
        #endif
    #else
    #warning "Current version is > " kVersionEight
    #endif
|))

((s2 Errors and warnings

The ((i #error i)) directive raises an error and stops the execution of the
compiler. This is generally used in combination with ((i #if i)) directives
to test for situations that should never occur.

The ((i #warning i)) directive emits a message in the console.
The ((i #message i)) directive is just a synonym for ((i #warning i)).

Here are a few examples:
((|
    #warning "Fix the version number before shipping"
    #message "PList Compiler is great!!!"
    #if __PLIST__ < 1.0
       #error "The property list version is too old"
    #endif
|))


((s2 Pragmas

Pragmas are directives used to modify the internal state of the compiler. 
They let you modify some internal settings during the execution of the plc 
file. They are most useful to modify locally a global setting: the new 
value set by a pragma holds until another pragma modifies it again. 
A pragma is declared with the ((i #pragma i)) directive. The syntax is:
((|
    #pragma pragma_name [pragma_value]
|))

The supported pragmas are explained below. The ((i pragma_name i)) argument
can be one of the following keywords:
((i output_filename,
in_package_directory,
localize_directory,
output_eol,
output_encoding,
plist_version. i))

Any other pragma encountered will be simply ignored by ((b PList Compiler
b)). In particular the ((i once i)), ((i notonce i)), and ((i mark i))
pragmas, defined by the CodeWarrior compiler, are not supported, as of
version 0.1.

((b Caution: b)) a pragma cannot be used inside a ((i plist i)) or a 
((i localize i)) block. It must be invoked outside these environments. This
is because the internal settings they affect can't be modified once a file
has been opened for output. The compiler will emit an error if such a 
situation occurs.


((s3 The 'output_filename' pragma
The ((i output_filename i)) pragma lets you override the default name 
of the current output file. Its value is a string which is the new name. 
For instance:
((|
    #pragma output_filename "OtherName.plist"
|))

The new name given with this pragma is used only once and then
forgotten, so that the compiler immediately returns to the default naming convention. 
Note that this does not affect the filename defined in a  'localize as' 
command. More precisely, if the compiler reads the following inxtructions:
((|
    #pragma output_filename "OtherName.txt"
    localize "Spanish" as "Error.strings"
    {
    }
|))
the pragma will have no effect and the output file will still be named 
((i Error.strings i)). On the other hand, the pragma will remain in effect 
until it can be applied. 


((s3 The 'in_package_directory' pragma
The ((i in_package_directory i)) pragma lets you specify where to place the
property list file inside the destination folder. It is a string which
specifies a directory ((i relative i)) to the destination folder. For instance, if
you write:
((|
    #pragma in_package_directory "Infos"
|))
the ((i Info.plist i)) file will be written in an ((i Infos i)) subfolder
of the destination folder rather than in the destination folder directly.
If the subfolder does not exist, it is created. By default, this will be
((i MyApp.app/Contents/Infos i)) (unless another destination folder has 
been otherwise specified).

Another valid value for this pragma could be:
((|
    #pragma in_package_directory "../Infos/Properties"
|))
which would write the output file in ((i MyApp.app/Infos/Properties i)),
i-e with the ((i Infos i)) directory at the same level as the 
((i Contents i)) directory.


((s3 The 'localize_directory' pragma
While the previous pragma affected the final location of the ((i Info.plist i))
files (produced by the ((i plist i)) command), the ((i localize_directory i))
pragma lets you specify where to place the localized strings files produced
by the ((i localize i)) command. It is a string which specifies a directory
((i relative i)) to the destination folder. By default, it is the ((i Resources i))
folder inside the destination folder which itself is, by default, the
((i Contents i)) subfolder of the bundle. For instance:
((|
    #pragma localize_directory "Local/Strings/"
|))
will cause the localized strings files to be written in some 
((i MyApp.app/Contents/Local/Strings/<language>.lproj i)) folder 
(depending on the chosen language) instead of 
((i MyApp.app/Contents/Resources/<language>.lproj i)).


((s3 The 'output_eol' pragma
The ((i output_eol i)) pragma lets you specify another type of line endings
for the output files. The possible values are ((i cr i)) for Mac, 
((i lf i)) for Unix and ((i crlf i)) for Windows. This pragma is useful to
override a setting made with the ((i -output_eol i)) option on the command
line of the ((b plcompile b)) shell script.
((|
    #pragma output_eol lf
|))


((s3 The 'output_encoding' pragma
The ((i output_eol i)) pragma lets you specify another encoding
for the output files. The possible values are listed when you execute the 
command:
((|
    plcompile -help
|))

You would normally be interested only in the utf-8 and utf-16 encoding forms 
which are the only encodings recognized for property list files. ((b PList 
Compiler b)) is able though to handle all the other encodings.

This pragma is useful to override a setting made with the 
((i -output_encoding i)) option on the command line of the ((b plcompile b))
shell script. For instance:
((|
    #pragma output_encoding utf-16
|))

Note that there is no equivalent pragma concerning the input encoding
because it does not make sense: the input file would have already been read
when the pragma is encountered.

((s3 The 'plist_version' pragma
The ((i plist_version i)) pragma lets you specify another version of the 
property list format. The possible values currently are 0.9 and 1.0. This is 
the value written in the ((i version i)) attribute of the <plist> tag in the 
((i .plist i)) files. For instance:
((|
    #pragma plist_version 0_9
|))
yields
<plist version="0_9">

This is the same value stored in the ((v __PLIST__ v)) predefined variable
(see below).

((s1 Substitutable variables

Substitutable variables are variables whose value is inserted when the 
script is run. These variables can be defined with a ((i #define i)) preprocessor 
macro or in the shell environment. There are also some useful predefined 
variables set by the plc compiler itself.

To invoke a variable defined in the shell environment, you must surround it with 
double underscores. This concerns in particular all 
the variables available in an XCode project, but not only: ordinary shell 
environment variables, such as ((v USER v)), ((v DISPLAY v)), ((v SHELL v)), 
etc. are also accessible as ((v __USER__ v)), ((v __DISPLAY__ v)), 
((v __SHELL__ v)), respectively.

Variables defined with a ((i #define i)) macro can be invoked directly 
(without the double underscores). For 
instance, if you define
((|
    #define kBundleShortVersion "1.2.3"
|))
you can then have a key in the ((i plist i)) dictionary declared like this
((|
    key "CFBundleVersion" value string kBundleShortVersion
|))

For variables which can be set at different levels, the order of precedence
is the following: an option set by a ((i #define i)) directive or modified
by a ((i #pragma i)) directive in the plc source file overrides any option
set on the command line which, in turn, overrides an option set by a shell
environment variable.


((s2 Predefined variables

A few predefined variables are set each time the ((b plcompile b)) script is 
run. 

The five following variables existed in the CodeWarrior property list
compiler. They are still available with ((b PList Compiler b)) in order to
ensure some compatibility with already existing plc files (and because they
are very useful!):
((ld
((lt __FILE__
This variable always contains the name of the file currently processed. If
another file is included with an ((i #include i)) preprocessor macro, the
value of the variable is changed accordingly so that it always designates
the file being processed. 
lt))
((lt __OUTPUT_CREATOR__
This variable contains the creator
type of the built product. It corresponds to the MACOS_CREATOR XCode variable.
lt))
((lt __OUTPUT_TYPE__
This variable contains the file
type of the built product. It corresponds to the MACOS_TYPE XCode variable.
lt))
((lt __OUTPUT_FILENAME__
This variable contains the name of the built product. It is equivalent to 
the concatenation of the PRODUCT_NAME and
WRAPPER_EXTENSION XCode variables.
lt))
((lt __DATE__
This is the complete date at the moment where the script is executed. It is
returned in the format specified by the ISO 8601 standard:
YY-MM-DDTHH:MM:SSZ. For instance ((i "2005-10-04T17:12:23Z" i)).
lt))
ld))

((b Caveat: b)) one must be aware that the values of the ((v OUTPUT_CREATOR v)) 
and ((v OUTPUT_TYPE v)) predefined variables are taken from the XCode
variables called ((v MACOS_CREATOR v)) and ((v MACOS_TYPE v)), but that, in
certain circumstances, these variables are not displayed in the ((i Target
Settings i)) panels in ((i XCode i)). The variables do exist but simply
are not displayed by default.  As a consequence, their value in that case
is empty. This is a problem with ((i XCode i)), not with ((i PList
Compiler i)). The remedy, should this situation occur, is to add these
variables manually in the ((i Target Settings i)) using the ((i Plus i))
button and to give them the necessary values corresponding to your project.

Furthermore ((b PList Compiler b)) introduces other useful predefined variables: 
((ld
((lt __YEAR__
The current year (four digits)
lt))
((lt __MONTH__
The current month number (01 - 12)
lt))
((lt __MONTHNAME__
The full month name (January, etc.)
lt))
((lt __DAY__
The current day of month (01 - 31)
lt))
((lt __DAYNAME__
The full day name (Monday, etc.)
lt))
((lt __SHORTDATE__
The current date as YYYY-MM-DD.
lt))
((lt __TIME__
The current time as HH:MM::SS.
lt))
((lt __HOURS__
The hours part of the TIME string.
lt))
((lt __MINUTES__
The minutes part of the TIME string.
lt))
((lt __SECONDS__
The seconds part of the TIME string.
lt))
ld))

For instance:
((|
    __DATE__      = 2005-10-04T15:54:36Z
    __SHORTDATE__ = 2005-10-04
    __YEAR__      = 2005
    __MONTH__     = 10
    __MONTHNAME__ = October
    __DAY__       = 04
    __DAYNAME__   = Tuesday
    __TIME__      = 15:54:36
    __HOURS__     = 15
    __MINUTES__   = 54
    __SECONDS__   = 36
|))


((s2 XCode environment variables

All the environment variables set by an XCode project are accessible with 
((b PList Compiler b)). See the XCode documentation for a 
complete list. The syntax is the same as for the predefined variables: 
the name of the environment variable must be surrounded by double 
underscores. For instance, if you want to invoke the value of the 
INFOPLIST_PATH variable defined in an XCode project, you would write it as ((v __INFOPLIST_PATH__ v))
in the plc file. For instance
((|
    key "InfoPlistPath" value string __INFOPLIST_PATH__
|))

Some of these variables are set by XCode itself (they are generally meant
to be read-only variables) while the others can be set in the info window
or a particular target. The name of a variable corresponding to a
particular setting is always indicated by XCode between parentheses in the
help text displayed when you select this setting in a Target Info window.

((s2 Unsupported variables

A few predefined variables available in the CodeWarrior property list 
compiler are not supported by ((b PList Compiler b)). This is mainly because they 
are specific to the CodeWarrior IDE and have no meaning with XCode. Here 
is the list of these variables:
((|
    __APPLEMACHLINKER__, __MACH__, __MERGELINKER__, 
    __MWMACHLINKER__, __MWPEFLINKER__
|))

The ((v __LINE__ v)) variable is not supported either, as well as the 
((v __IDE_TARGET__() v)) and ((v __STRING__() v)) pseudo-macros.


((s1 Unicode characters

By default, ((b PList Compiler b)) assumes that the input file is UTF-8 encoded 
and it generates its output files in the same encoding. So there is no 
problem for supporting any Unicode character in your plc source files: you 
just have to use a text editor which handles the UTF-8 encoding form.
If you prefer editing your plc source files in macRoman, all you have to 
do is to specify this to the ((i plcompile i)) script using the ((i -input_encoding i)) 
option. 

Alternatively, if you just need occasionnally to use Unicode characters,
you can also embed them in strings using the ((v \u v)) escape sequence:
each Unicode character can be designated using the sequence ((v \u v))
followed by the code-point of the character in hexadecimal. For instance,
the Unicode code-points for the lowercase letters of the greek alphabet
start at 03B1:
((t1
((tr ((i Code-point i))	((i Letter i))
((tr 03B1	GREEK SMALL LETTER ALPHA
((tr 03B2	GREEK SMALL LETTER BETA
((tr 03B3	GREEK SMALL LETTER GAMMA
((tr 03B4	GREEK SMALL LETTER DELTA
((tr 03B5	GREEK SMALL LETTER EPSILON
((tr 03B6	GREEK SMALL LETTER ZETA
((tr 03B7	GREEK SMALL LETTER ETA
((tr 03B8	GREEK SMALL LETTER THETA
((tr 03B9	GREEK SMALL LETTER IOTA
t))
A string defined like this
((|
    	key "UniString1" value string "\u03B1 \u03B2 \u03B3 \u03B4 \u03B5 \u03B6 \u03B7 \u03B8 \u03B9"
|))
will produce:
((im Images/plc_greekletters.jpg
String with greek letters im))

((b Note: b)) the sequence to designate Unicode characters is ((v \u v)) with a 
((i lowercase u i)). This is a difference with the CodeWarrior property
list compiler which used \U.


((s1 Download
((b PList Compiler b)) is an Open Source Project. Its source code is 
freely available and can 
be found on the SourceForge site at the following address:
((nl <http://sourceforge.net/projects/plistcompiler>

((nl PList Compiler releases are available at
((nl <http://sourceforge.net/project/showfiles.php?group_id=149940> 
((nl or on my web 
page at 
((nl <http://webperso.easyconnect.fr/bdesgraupes/plistcompiler.html>

((nl The code is under CVS control. You can retrieve the latest stage of 
development using any CVS client. See instructions at:
((nl <http://sourceforge.net/cvs/?group_id=149940>

((nl You can browse the cvs repository online at
((nl <http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/plistcompiler> 

((nl You can also download a nightly tarball from
((nl <http://cvs.sourceforge.net/cvstarballs/plistcompiler-cvsroot.tar.bz2>



((s1 Known problems
((nl Please e-mail any problem or bug you encounter:
((nl <bdesgraupes@users.sourceforge.net>
((nl Visit my Web page for updates and other recent builds:
((nl <http://webperso.easyconnect.fr/bdesgraupes/plistcompiler.html>
((nl Visit the PList Compiler project area on the SourceForge site:
((nl <http://sourceforge.net/projects/plistcompiler>

There is also a mailing list, ((b plistcompiler-users b)), for discussing any
topics related to the usage of PList Compiler and its future development. New 
versions will be announced on this list
too. You can subscribe or unsubscribe from the following address:
((nl <http://lists.sourceforge.net/mailman/listinfo/plistcompiler-users>
To post to this list, send mail to
<plistcompiler-users@lists.sourceforge.net>


((s1 Version history
For a detailed list of the changes, see the file ((i Changes_PLC i)) in 
the CVS repository.
((lu
((li 2005-10-10 - 0.1b1 - First public beta release. Basic implementation.
((li 2005-10-12 - 0.1b2 - Fixed bug when #including pathname with whitespace.
((li 2005-10-13 - 0.1b3 - Improved use of single quotes. Minor fixes. 
Unicode characters.
((li 2005-10-14 - 0.1rc1 - First release candidate.
((li 2005-11-03 - 0.1 - First final release. Added -version option.
lu))


((s1 License and disclaimer

((b PList Compiler b)) is distributed under the same BSD License as
the Tcl language itself: see the file ((i License_terms i)) in the distribution or 
the ((lk http://www.opensource.org/licenses/bsd-license )) Open Source Initiative site. lk))




((-
((nl Last updated ((s [ISOTime::ISODateAndTimeRelaxed] s))
!! logo SF
!! -------
((if $aida_params(target) eq "Html"
((-
((nl ((i PList Compiler is hosted by i)) 
((lk http://sourceforge.net )) ((im http://sourceforge.net/sflogo.php?group_id=149940&amp;type=4 
SourceForge.net Logo im)) lk))
if))

