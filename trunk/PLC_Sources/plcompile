# -*-Tcl-*-
#!/bin/bash
# the next line restarts using tclsh \
exec tclsh "$0" "$@"

# ===========================================================================
# File: "PlistComp.tcl"
#                        Created: 2005-10-01 21:46:19
#              Last modification: 2006-11-05 14:24:40
# Author: Bernard Desgraupes
# e-mail: <bdesgraupes@users.sourceforge.net>
# www: <http://sourceforge.net/projects/plistcompiler>
# (c) Copyright: Bernard Desgraupes 2005-2006
# All rights reserved.
# ===========================================================================

namespace eval plc {}

unset -nocomplain plc_def plc_predef plc

# Current version number
set plc(version) "0.5"

# Retrieving the values of the shell variables: the env array contains the
# values for all the environment variables defined by XCode.
array set plc_predef [array get env]

# Legacy: predefined variables of the CodeWarrior property list compiler 
if {[info exists plc_predef(MACOS_CREATOR)]} {
	set plc_predef(OUTPUT_CREATOR) $plc_predef(MACOS_CREATOR)
	set plc(bundle_signature) $plc_predef(MACOS_CREATOR)
} else {
	set plc_predef(OUTPUT_CREATOR) ""
	set plc(bundle_signature) "????"
}
if {[info exists plc_predef(MACOS_TYPE)]} {
	set plc_predef(OUTPUT_TYPE) $plc_predef(MACOS_TYPE)
	set plc(bundle_type) $plc_predef(MACOS_TYPE)
}  else {
	set plc_predef(OUTPUT_TYPE) ""
	set plc(bundle_type) "????"
}
if {[info exists plc_predef(PRODUCT_NAME)]} {
	set plc_predef(OUTPUT_FILENAME) $plc_predef(PRODUCT_NAME)
}  else {
	set plc_predef(OUTPUT_FILENAME) ""
}
	
# Predefined variables
# --------------------
# Enclose them between double underscores to invoke 
# them in the plc file. For instance __DATE__ or __YEAR__
set plc_predef(DATE) [clock format [clock seconds] -format "%Y-%m-%dT%H:%M:%SZ"]
set plc_predef(SHORTDATE) [clock format [clock seconds] -format "%Y-%m-%d"]
set plc_predef(YEAR) [clock format [clock seconds] -format "%Y"]
set plc_predef(MONTH) [clock format [clock seconds] -format "%m"]
set plc_predef(MONTHNAME) [clock format [clock seconds] -format "%B"]
set plc_predef(DAY) [clock format [clock seconds] -format "%d"]
set plc_predef(DAYNAME) [clock format [clock seconds] -format "%A"]
set plc_predef(TIME) [clock format [clock seconds] -format "%H:%M:%S"]
set plc_predef(HOURS) [clock format [clock seconds] -format "%H"]
set plc_predef(MINUTES) [clock format [clock seconds] -format "%M"]
set plc_predef(SECONDS) [clock format [clock seconds] -format "%S"]

# Initializations
# ---------------
set plc(context) ""
set plc(contextlevel) 0
set plc(parsing) 0
set plc(localizing) 0
set plc(pkginfo) 0
set plc(currkey) ""
set plc(escape_entities) 1

set plc_predef(PLIST) "1.0"
set plc(output_filename) ""
# (vs 0.4) Use TARGET_BUILD_DIR instead of BUILT_PRODUCTS_DIR to point to
# the correct location regardless of the value of DEPLOYMENT_LOCATION
if {[info exists plc_predef(TARGET_BUILD_DIR)] && [info exists plc_predef(INFOPLIST_PATH)]} {
	set plc(output_folder) [file join $plc_predef(TARGET_BUILD_DIR) [file dir $plc_predef(INFOPLIST_PATH)]]
} 
set plc(in_package_directory) ""
set plc(localize_directory) "Resources"

if {[info exists plc_predef(HEADER_SEARCH_PATHS)]} {
	set plc(search_path) $plc_predef(HEADER_SEARCH_PATHS)
}  else {
	set plc(search_path) ""
}

set plc(input_encoding) "macRoman"
set plc(output_encoding) "utf-8"
set plc(input_eol) "cr"
set plc(output_eol) "cr"
set plc(eols) [list "cr" "lf" "crlf"]

# Nesting level of a conditional block (anything between an if and the 
# corresponding endif).
# 		if endif
# 		if else endif
# 		if elif [elif..] endif
# 		if elif [elif..] else endif
# Level 0 means outside of any conditional block.
set plc(iflevel) 0
# plc(execdone-XX) tells if some previous section of a conditional block at
# level XX has already been executed. If yes, no other section can be made
# executable.
set plc(execdone-1) 0
# plc(doexec-XX) tells if execution is active at a level XX. Level 0 is 
# always executable.
set plc(doexec-0) 1

# Base64 encoding
set plc(base64) [list \
  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
  a b c d e f g h i j k l m n o p q r s t u v w x y z \
  0 1 2 3 4 5 6 7 8 9 + / ]
set plc(wraplen) 60

# Main proc
proc plc::execute {args} {
	global plc plc_predef
	set len [llength $args]
	if {$len == 0 || $len > 14} {
		puts "Error: wrong number of arguments"
		plc::usage
		return
	} 
	# Handle the -help option
	if {$len == 1 && [regexp -- "-h" $args]} {
		plc::usage 1 
		return
	} 
	# Handle the -help option
	if {$len == 1 && [regexp -- "-v" $args]} {
		puts "$plc(version)"
		return
	} 
	# Handle the -encodings option
	if {$len == 1 && [regexp -- "-e" $args]} {
		puts "Available encodings:"
		puts [join [lsort [concat [encoding names] "utf-16"]] ", "]
		return
	} 
	# Retrieve the last argument
	set srcfile [file normalize [lindex $args end]]
	if {$srcfile eq ""} {
		puts "Error: no file specified"
		plc::usage
		return
	} 
	if {![file exists $srcfile]} {
		error "can't find '$srcfile'. No such file or directory."
	} 
	set plc(input_file) $srcfile
	# Define a default output folder in case nothing was inherited 
	# from the XCode settings (for instance, if the script is used directly 
	# from Terminal). This can be overridden by a -dest option below.
	if {![info exists plc(output_folder)]} {
		set plc(output_folder) [file dir $srcfile]
	} 

	# Parse the options
	incr len -1
	set failed 0
	for {set i 0} {$i < $len} {incr i} {
		# Ignore the leading hyphen
		set elem [string trimleft [lindex $args $i] "-"]
		switch -- $elem {
			"input_encoding" 
			- "output_encoding" {
				incr i
				if {$i <= $len} {
					set value [lindex $args $i]
					if {$value eq "utf-16"} {
						set value "unicode"
					} 
					if {[lsearch [encoding names] $value] == -1} {
						puts "Error: wrong value '$value' for encoding option.\nShould be one of [join [lsort [concat [encoding names] "utf-16"]] ", "]"
						return
					} 
					set plc($elem) $value
				} else {
					set failed 1
				}
			}
			"input_eol"
			- "output_eol" {
				incr i
				if {$i <= $len} {
					set value [lindex $args $i]
					if {[lsearch $plc(eols) $value] == -1} {
						puts "Error: wrong value '$value' for eol option. Should be one of [join $plc(eols) ", "]."
						return
					} 
					set plc($elem) $value
				} else {
					set failed 1
				}
			}
			"dest" {
				incr i
				if {$i < $len} {
					set plc(output_folder) [file normalize [lindex $args $i]]
				} else {
					set failed 1
				}
			}
			"o" {
				# Vs-0.5: implement an -o option (this slightly modifies
				# patch 1474228 contributed by Jens Miltner - thanks).
				# If a full path is passed (i-e the string starts with a
				# slash), set output_folder and output_folder accordingly,
				# otherwise use the value as the output file name and build
				# output_folder as usual.
				incr i
				if {$i < $len} {
					set outname [lindex $args $i]
					if {[string range $outname 0 0] eq "/"} {
						set plc(output_folder) [file dir $outname]
						set plc(output_filename) [file tail $outname]
					} else {
						set plc(output_filename) $outname
					}
				} else {
					set failed 1
				}
			}
			"plist" {
				incr i
				if {$i < $len} {
					set plc_predef(PLIST) [lindex $args $i]
				} else {
					set failed 1
				}
			}
			"pkginfo" {
				set plc(pkginfo) 1
			}
			"prefix" {
				incr i
				if {$i < $len} {
					set prefixFile [file normalize [lindex $args $i]]
				} else {
					set failed 1
				}
			}
			default {
				error "unknown option $elem"
			}
		}
		
		if {$failed} {
			puts "Error: missing value for option '$elem'\n"
			plc::usage
			return
		} 
	} 
	
	if {[info exists prefixFile]} {
		if {[file exists $prefixFile]} {
			plc::processFile $prefixFile
		} else {
			error "can't find prefix file $prefixFile"
		}
	}
	
	# Now call the compiler
	plc::processFile $srcfile

	# Generate PkgInfo file, if requested
	if {$plc(pkginfo)} {
		plc::generatePkgInfo
	}
}

# Regexp to capture C-like comments (works with the (?w) directive or
# -lineanchor option):
#         /\*([^*]|\*+[^*/])*\*+/
proc plc::normalize {txt} {
	# Strip comments: if a line starts with // it is deleted
	# unconditionnally. If the // is not at the beginning of the line, it
	# is considered as a comment only if there is no double quote after it
	# otherwise it might be a double slash inside a quoted string.
	regsub  -line -all {^//.*$} $txt {} txt
	regsub  -line -all {//[^"]*$} $txt {} txt
	regsub -all -lineanchor {/\*([^*]|\*+[^*/])*\*+/} $txt {} txt
	# Cut all the instructions
	regsub -all {\s+value\s+(dictionary|array)\s*} $txt "\r\\1\r" txt
	regsub -all {\s+value\s+(boolean|number|date|data|string)} $txt "\r\\1" txt
	regsub -line -all {^\s*(plist|dictionary|array)\s*} $txt "\\1\r" txt
	regsub -all {^({|\[)\s*(}|\])} $txt "\\1\r\\2" txt
	# Align them on the left margin
	regsub -line -all "^\[ \t\]+" $txt "" txt
	# Remove empty lines
	regsub -line -all "^\[\r\n\]" $txt "" txt
	return $txt	
}

proc plc::processFile {file} {
	global plc
	# The existence of the file has been checked by the caller
	set fid [open $file]
	fconfigure $fid -encoding $plc(input_encoding) -translation $plc(input_eol)
	set txt [read $fid]
	close $fid
	plc::parseContents $txt
}

proc plc::parseContents {txt} {
	global plc
	set txt [split [plc::normalize $txt] "\r\n"]
	set len [llength $txt]
	for {set index 0} {$index < $len} {incr index} {
		set line [lindex $txt $index]
		if {[string length $line] == 0} {
			continue
		} 
		# Look at the first character of the line
		set first [string range $line 0 0]
		
		switch -- $first {
			"#" {
				# This is a preprocessor macro. The [plc::parseMacro] proc 
				# returns the number of lines it has parsed
				plc::parseMacro $line
			}
			"{" - "\[" {
				# nothing
			}
			"}" - "\]" {
				if {[set plc(doexec-$plc(iflevel))]} {
					plc::contextEnd $first
				}
			}
			default {
				if {[set plc(doexec-$plc(iflevel))]} {
					if {[regexp {^(\w+)\s*(.*)$} $line -> cmd arg]} {
						switch -- $cmd {
							"plist"
							- "dictionary"
							- "array"
							- "string"
							- "boolean"
							- "date"
							- "data"
							- "number" 
							- "key" 
							- "comment" 
							- "localize" {
								if {[info exists arg]} {
									# Replace outer single quotes (if any) by double quotes
									regsub "^'(.*)'$" $arg "\"\\1\"" arg
									eval plc::parse[string totitle $cmd] [plc::quote $arg]
								} else {
									plc::parse[string totitle $cmd]
								}
							}
							default {
								error "unknown command '$cmd'"
							}
						}
					} 
				} 
			}
		}
	}
}

proc plc::parseMacro {line} {
	global plc plc_def plc_predef
	if {[regexp {#[ \t]*(\w+)[ \t]*([^\r\n]*)$} $line -> macro definition]} {
		if {[set plc(doexec-$plc(iflevel))]} {
			switch -- $macro {
				"if" {
					incr plc(iflevel)
					set value ""
					foreach a $definition {
						append value [plc::substitute $a]
					} 
					set condition [eval expr [list $value]]
					set plc(execdone-$plc(iflevel)) $condition
					set plc(doexec-$plc(iflevel)) $condition
				}
				"ifdef" {
					incr plc(iflevel)
					set var $definition
					set condition [expr [info exists plc_def($var)] || [info exists plc_predef($var)]]
					set plc(execdone-$plc(iflevel)) $condition
					set plc(doexec-$plc(iflevel)) $condition
				}
				"ifndef" {
					incr plc(iflevel)
					set var $definition
					set condition [expr ![info exists plc_def($var)] && ![info exists plc_predef($var)]]
					set plc(execdone-$plc(iflevel)) $condition
					set plc(doexec-$plc(iflevel)) $condition
				}
				"elif" {
					set plc(doexec-$plc(iflevel)) 0
				}
				"else" {
					set plc(doexec-$plc(iflevel)) 0
				}			
				"endif" {
					set plc(execdone-$plc(iflevel)) 0
					set plc(doexec-$plc(iflevel)) 0
					incr plc(iflevel) -1
				}
				"include" {
					plc::processInclude $definition					
				}
				"define" {
					if {[regexp {(\w+)[ \t]*([^\r\n]*)$} $definition -> value arg]} {
						# (Bug 1413845) Predefined variables are invoked as
						# __VAR__ but the user can also have variables
						# using this scheme, so we must check. The former
						# would be in the plc_predef array and the latter
						# in the plc_def array. If a user variable
						# conflicts with a predefined one, the new var
						# overwrites the old one and a warning is issued.
						set strip ""
						set stripped [regexp "^__(.+)__$" $value -> strip]
						if {$stripped && [info exists plc_predef($strip)]} {
							puts "#warning: macro '$value' is overwriting the predefined variable '$strip'"
							set plc_predef($strip) ""
							# Replace outer single quotes (if any) by double quotes
							regsub "^'(.*)'$" $arg "\"\\1\"" arg
							foreach a $arg {
								append plc_predef($strip) [plc::substitute $a]
							} 
						} elseif {[info exists plc_def($value)]} {
							error "macro '$value' already defined"
						} elseif {[info exists plc_predef($value)]} {
							error "macro '$value' conflicts with predefined macro"
						} else {
							set plc_def($value) ""
							# Replace outer single quotes (if any) by double quotes
							regsub "^'(.*)'$" $arg "\"\\1\"" arg
							foreach a $arg {
								append plc_def($value) [plc::substitute $a]
							} 
						}
					} 
				}
				"undef" {
					if {[regexp {\w+} $definition value]} {
						if {[info exists plc_predef($value)]} {
							error "can't undef predefined macro '$value'"
						} 
						unset -nocomplain plc_def($value)
					} 
				}
				"error" {
					set value ""
					foreach a $definition {
						append value [plc::substitute $a]
					} 
					puts "#error: $value"
					error "processing interrupted by #error macro"
				}
				"warning" - "message" {
					set value ""
					foreach a $definition {
						append value [plc::substitute $a]
					} 
					puts "[string totitle $macro]: $value"
				}
				"pragma" {
					if {[regexp {(\w+)[ \t]*([^\r\n]*)$} $definition -> name arg]} {
						set value ""
						foreach a $arg {
							append value [plc::substitute $a]
						} 
						plc::parsePragma $name $value
					}
				}
			}
		} else {
			switch -- $macro {
				"if" - "ifdef" - "ifndef" {
					incr plc(iflevel)
					set plc(execdone-$plc(iflevel)) 0
					set plc(doexec-$plc(iflevel)) 0
				}
				"elif" {
					# Check if execution is on at the preceding level
					if { $plc(iflevel) \
					  && [set plc(doexec-[expr {$plc(iflevel) - 1}])] \
					  && !$plc(execdone-$plc(iflevel)) } {
						# Evaluate the condition
						set value ""
						foreach a $definition {
							append value [plc::substitute $a]
						} 
						set condition [eval expr [list $value]]
						set plc(execdone-$plc(iflevel)) $condition
						set plc(doexec-$plc(iflevel)) $condition
					} 
				}
				"else" {
					if { $plc(iflevel) \
					  && [set plc(doexec-[expr {$plc(iflevel) - 1}])] \
					  && !$plc(execdone-$plc(iflevel)) } {
						set plc(execdone-$plc(iflevel)) 1
						set plc(doexec-$plc(iflevel)) 1
					} 
				}
				"endif" {
					set plc(execdone-$plc(iflevel)) 0
					set plc(doexec-$plc(iflevel)) 0
					incr plc(iflevel) -1
				}
			}
		} 
	} 
}

# Use the HEADER_SEARCH_PATHS variable to resolve includes.
# Author: Franz Detro <franz.detro@native-instruments.de>
proc plc::processInclude {name} {
	global plc 
	
	set saveFile $plc(input_file)
	set headerPathOnly 0
	
	# Remove outer < > (if any)
	if {[regsub "^<(.*)>$" $name "\\1" name]} {
		set headerPathOnly 1
	} 	
	# Remove outer quotes and whitespace chars
	set name [string trim $name "\""]
	
	if {[file exists $name]} {
		# 'name' is an absolute path
		set plc(input_file) $name
	} else {
		set found 0
		if {!$headerPathOnly} {
			# Search relatively to the dir of the parent file
			set plc(input_file) [file normalize [file join [file dir $saveFile] $name]]
			set found [file exists $plc(input_file)]
		}
		# If the file does not exist, search the HEADER_SEARCH_PATHS dirs
		if {!$found} {
			foreach dir $plc(search_path) {
				set candidate [file normalize [file join $dir $name]]			
				if {[file exists $candidate]} {			
					set plc(input_file) $candidate
					set found 1
					break
				}
			} 
		} 
		if {!$found} {
			error "can't find file '$name' to include"
		} 
	} 
	
	plc::processFile $plc(input_file)
	set plc(input_file) $saveFile
}

proc plc::parsePragma {name value} {
	global plc plc_predef
	# Pragmas are not allowed inside a 'plist' or 'localize' block
	if {$plc(parsing)} {
		error "illegal '#$name' pragma in plist block"
	}
	switch -- $name {
		"output_encoding" {
			if {$value eq "utf-16"} {
				set value "unicode"
			} 
			set plc(output_encoding) $value
		}
		"plist_version" {
			set plc_predef(PLIST) $value
		}
		"escape_entities" {
			 if {$value eq "on"} {
				 set value 1
			 } elseif {$value eq "off"} {
				 set value 0
			 } 
			 set plc($name) $value
		}
		"output_filename" 
		- "in_package_directory" 
		- "localize_directory" 
		- "output_eol" {
				set plc($name) $value
		}
		"mark" {
			# Silently ignored
		}
		"once" - "notonce" {
			# Not supported
			puts "ignoring unsupported pragma $name"
		}
		default {
			# Ignore other pragmas
			puts "ignoring unknown pragma $name"
		}
	}
}

proc plc::parsePlist {args} {
	global plc plc_predef
	plc::checkContext plist
	set outfolder [file normalize [file join $plc(output_folder) $plc(in_package_directory)]]
	if {![file exists $outfolder]} {
		file mkdir $outfolder
	} 
	# See if a custom name has been declared by an output_filename pragma
	# (or, since version 0.5, by an -o option on the command line)
	if {[info exists plc(output_filename)] && $plc(output_filename) ne ""} {
		set outname $plc(output_filename)
		unset -nocomplain plc(output_filename)
	} else {
		set outname "Info.plist"
	}
	set outfile [file join $outfolder $outname]
	set plc(outid) [open $outfile w+]
	fconfigure $plc(outid) -encoding $plc(output_encoding) -translation $plc(output_eol)
	plc::writePreamble
	plc::writeTag "plist version=\"$plc_predef(PLIST)\"" 
	plc::contextStart "plist"
}

proc plc::parseDictionary {args} {
	plc::writeTag "dict"
	plc::contextStart "dict"
}

proc plc::parseArray {args} {
	plc::writeTag "array"
	plc::contextStart "array"
}

proc plc::parseString {args} {
	global plc
	set value ""
	foreach a $args {
		append value [plc::substitute $a]
	} 
	
	if {$plc(escape_entities)} {
		# (vs 0.4) Substitute entities for the &, ', ", < and > symbols
		regsub -all {&} $value {\&amp;} value
		regsub -all {<} $value {\&lt;} value
		regsub -all {>} $value {\&gt;} value
		regsub -all {"} $value {\&quot;} value
		regsub -all {'} $value {\&apos;} value
	} 
	
	if {$plc(localizing)} {
		plc::writeOut "\"$value\";\r"
	} else {
		plc::writeTag string
		plc::writeOut $value
		plc::writeTag string close
		if {$plc(pkginfo)} {
			if {$plc(currkey) eq "CFBundleSignature"} {
				set plc(bundle_signature) $value			
			} elseif {$plc(currkey) eq "CFBundlePackageType"} {
				set plc(bundle_type) $value
			}
		} 
	}
}

proc plc::parseBoolean {args} {
	# Accept any casing (true, TRUE, True etc)
	set args [string tolower $args]
	# Accept other boolean values (yes/no, 1/0)
	if {$args eq "yes" || $args == 1} {
		set args "true"
	} elseif {$args eq "no" || $args == 0} {
		set args "false"
	} 
	# Reject other values
	if {$args ne "true" && $args ne "false"} {
		error "Illegal '$args' value for boolean keyword"
	} else {
		plc::writeTag $args empty
	}	
}

proc plc::parseDate {args} {
	plc::writeTag date
	set value ""
	foreach a $args {
		append value [plc::substitute $a]
	} 
	plc::writeOut $value
	plc::writeTag date close
}

proc plc::parseData {args} {
	plc::writeTag data
	set data ""
	foreach a $args {
		append data $a
	} 
	regsub -all " " $data "" data
	# Do some checking
	if {![string is xdigit $data]} {
		error "Illegal hex data: $data"
	} 
	if {[expr {[string length $data] % 2}]} {
		error "expected even number of hex digit but got $data"
	} 
	# Need to convert to Base64 here. Todo...
	plc::writeOut [plc::encodeBase64 $data]
	plc::writeTag data close
}

proc plc::parseNumber {args} {
	set value ""
	foreach a $args {
		append value [plc::substitute $a]
	} 
	# Check the value format 
	if {![string is double $value]} {
		error "not a number '$value'"
	} 
	if {[regexp {\.} $value]} {
		set num real
	} else {
		set num integer
	}
	plc::writeTag $num
	plc::writeOut $value
	plc::writeTag $num close
}

proc plc::parseKey {args} {
	global plc
	set value ""
	foreach a $args {
		append value [plc::substitute $a]
	} 
	if {$plc(localizing)} {
		plc::writeOut "\"$value\" = "
	} else {
		plc::writeTag "key"
		plc::writeOut $value
		plc::writeTag "key" close
		set plc(currkey) $value
	}
}

proc plc::parseComment {args} {
	global plc
	set context [lrange $plc(context) 0 0]
	if {$context eq "localize"} {
		set value ""
		foreach a $args {
			append value [plc::substitute $a]
		} 
		set txt "/* $value */\r"
		plc::writeOut $txt
	} else {
		error "illegal 'comment' keyword in $context block"
	}
}

proc plc::parseLocalize {args} {
	global plc 
	plc::checkContext localize
	set plc(localizing) 1
	set lang [lindex $args 0]
	if {$lang ne ""} {
		set outfolder [file join $plc(output_folder) $plc(localize_directory) $lang.lproj]
	} else {
		error "no language specified with 'localize' keyword"
	}
	if {![file exists $outfolder]} {
		file mkdir $outfolder
	} 
	# Look for more arguments ('localize as "language"')
	set outname ""
	if {[lindex $args 1] eq "as"} {
		set outname [lindex $args 2]
	} 
	if {$outname eq ""} {
		if {[info exists plc(output_filename)] && $plc(output_filename) ne ""} {
			set outname $plc(output_filename)
			unset -nocomplain plc(output_filename)
		} else {
			set outname "InfoPlist.strings"
		}
	} 	
	set outfile [file join $outfolder $outname]
	set plc(outid) [open $outfile w+]
	fconfigure $plc(outid) -encoding $plc(output_encoding) -translation $plc(output_eol)
	plc::contextStart "localize"
}

proc plc::quote {item} {
	regsub -all {(\[|\])} $item "\\\\&" item
	return $item
}

proc plc::substitute {item} {
	global plc plc_def plc_predef
	set result ""
	set var $item
	set strip $item
	set stripped [regexp "^__(.+)__$" $var -> strip]
	if {$strip eq "FILE"} {
		append result [file tail $plc(input_file)]
	} elseif {$stripped && [info exists plc_predef($strip)]} {
		append result $plc_predef($strip)
	} elseif {[info exists plc_def($var)]} {
		append result $plc_def($var)
	} else {
		append result $item
	}
	return $result
}

proc plc::contextStart {what} {
	global plc
	lappend plc(context) $what
	incr plc(contextlevel)
}

proc plc::contextEnd {what} {
	global plc
	set curr [lrange $plc(context) end end]
	set plc(context) [lreplace $plc(context) end end]
	incr plc(contextlevel) -1
	if {$curr ne "localize"} {
		plc::writeTag $curr close 1
	} 
	if {$curr eq "plist" || $curr eq "localize"} {
		close $plc(outid)
		set plc(parsing) 0
		set plc(localizing) 0
	} 
}

proc plc::checkContext {what} {
	global plc
	set context [lrange $plc(context) 0 0]
	if {$plc(parsing) || $context ne ""} {
		error "illegal '$what' keyword in context $context"
	} else {
		set plc(parsing) 1
	}
}

proc plc::writeOut {txt} {
	global plc
	puts -nonewline $plc(outid) $txt
}

# The 'which' argument can be "open", "close" or "empty".
proc plc::writeTag {tag {which "open"} {indent 0}} {
	global plc
	switch -- $which {
		"open" {
			if {[string match "plist*" $tag] || $tag eq "dict" || $tag eq "array"} {
				puts $plc(outid) "[plc::indent]<$tag>"				
			} else {
				puts -nonewline $plc(outid) "[plc::indent]<$tag>"
			}	
		}
		"close" {
			if {$indent} {
				puts $plc(outid) "[plc::indent]</$tag>"
			} else {
				puts $plc(outid) "</$tag>"
			}
		}
		"empty" {
			puts $plc(outid) "[plc::indent]<${tag}/>"
		}
	}
}

proc plc::writePreamble {} {
	global plc 
	set enc [string toupper $plc(output_encoding)]
	if {$enc eq "UNICODE"} {
		set enc "UTF-16"
	} 
	set preamble "<?xml version=\"1.0\" encoding=\"$enc\"?>\r"
	# <!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
	append preamble "<!DOCTYPE plist SYSTEM \"file://localhost/System/Library/DTDs/PropertyList.dtd\">"
	puts $plc(outid) $preamble
}

proc plc::indent {} {
	global plc
	return [string repeat \t $plc(contextlevel)]
}

proc plc::encodeBase64 {hexstring} {
	global plc

	set result {}
	set state 0
	set length 0
	# Convert the hex string to binary
	set string [binary format H* $hexstring]
	# Process the input bytes 3-by-3
	binary scan $string c* X
	foreach {x y z} $X {
		# Wrap if necessary
		if {$plc(wraplen) && $length >= $plc(wraplen)} {
			append result "\r"
			set length 0
		}
		
		append result [lindex $plc(base64) [expr {($x >>2) & 0x3F}]] 
		if {$y != {}} {
			append result [lindex $plc(base64) [expr {(($x << 4) & 0x30) | (($y >> 4) & 0xF)}]] 
			if {$z != {}} {
				append result \
				  [lindex $plc(base64) [expr {(($y << 2) & 0x3C) | (($z >> 6) & 0x3)}]]
				append result [lindex $plc(base64) [expr {($z & 0x3F)}]]
			} else {
				set state 2
				break
			}
		} else {
			set state 1
			break
		}
		incr length 4
	}
	if {$state == 1} {
		append result [lindex $plc(base64) [expr {(($x << 4) & 0x30)}]]== 
	} elseif {$state == 2} {
		append result [lindex $plc(base64) [expr {(($y << 2) & 0x3C)}]]=  
	}
	return $result
}

# Support for PkgInfo files introduced in vs 0.2.
# Author: Franz Detro <franz.detro@native-instruments.de>
proc plc::generatePkgInfo {} {
	global plc

	foreach typ [list "type" "signature"] {
		if {[string length $plc(bundle_$typ)] != 4} {
			puts "Warning: $typ must be 4-chars long. Using '????' instead of '$plc(bundle_$typ)' in PkgInfo"
			set plc(bundle_$typ) "????"
		} 
	} 
	set outfolder [file normalize [file join $plc(output_folder) $plc(in_package_directory)]]
	if {![file exists $outfolder]} {
		file mkdir $outfolder
	} 
	set outfile [file join $outfolder "PkgInfo"]
	set pkgid [open $outfile w+]
	fconfigure $pkgid -encoding $plc(output_encoding) -translation $plc(output_eol)
	puts $pkgid "$plc(bundle_type)$plc(bundle_signature)"
	close $pkgid
}

# Usage proc
proc plc::usage { {showAll 0} } {
	global plc
	set script [file tail [info script]]
	set year [clock format [clock seconds] -format "%Y"]
	if {$showAll} {
		puts "$script, version $plc(version)"
		puts "Copyright (c) 2005-$year, Bernard Desgraupes <bdesgraupes@users.sourceforge.net>"
	}
	puts "Usage:\n\t$script \[-input_encoding <enc>\] \[-output_encoding <enc>\] \[-input_eol <eol>\] \[-output_eol <eol>\] \[-dest <folder>\] \[-o <name>\] \[-plist <version>\] \[-pkginfo\] plcFile"
	puts "\t$script (-help | -encodings | -version)\n"
	if {$showAll} {
		puts "Default for -input_encoding is macRoman"
		puts "Default for -output_encoding is utf-8"
		puts "Default for -dest is dirname of \$TARGET_BUILD_DIR/\$INFOPLIST_PATH"
		puts "Default for -o is Info.plist"
		puts "Possible values for -input_eol and -output_eol: [join $plc(eols) ", "] (default is cr)"
		puts "Possible values for -plist: 0.9 and 1.0 (default is 1.0)"
		puts "Use the -pkginfo option to also generate a PkgInfo file"
	} 
}


# # Execute the command line now
# # ----------------------------
if {[info exists argv]} {
	if {[catch {eval plc::execute $argv} err]} {
		puts "Error: $err"
		# Don't leave pending file refs
		catch {close $plc(outid)}
		exit 1
	} 
} 


