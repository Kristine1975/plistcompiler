!! !! ===========================================================================
!! !! PListCompilerHelp.aida
!! !!                       Created: 2005-10-03 16:27:26
!! !!             Last modification: 2007-09-07 07:54:38
!! !! Author: Bernard Desgraupes
!! !! e-mail: <bdesgraupes@users.sourceforge.net>
!! !! www: <http://sourceforge.net/projects/plistcompiler>
!! !! (c) Copyright: Bernard Desgraupes 2003-2007
!! !! All rights reserved.
!! !! ===========================================================================

:Title:       PListCompilerHelp
:Man:Title:       plcompile
:DestFolder:  ../../PLC_Help
:Author:      Bernard DESGRAUPES <bdesgraupes@users.sourceforge.net>
:Homepage:    <http://sourceforge.net/projects/plistcompiler>
:Created:     2005-10-03 16:27:26
:Modified:    2007-09-07 07:54:38
:Keywords:    property list, xcode, compiler
:Source:      PlcAidaMacros.tcl
:ManSection:	1


!! !! ===================================
((if $aida_target eq "Html" || $aida_target eq "SplitHtml"
!! !! ===================================

((/
((b PList Compiler b)) is a property list compiler for Xcode. 
It is developed as an ((i Open Source i)) project coming with a BSD
License. The source code is currently hosted and developed on the 
((lk http://sourceforge.net/projects/plistcompiler ))SourceForge site. lk))
/))

((toc
!! !! ===================================
if))
!! !! ===================================
((nl This file documents version ((s [plc::getVersion] s)) of PList Compiler.

((s1 Introduction


((b PList Compiler b)) is a property list compiler for Xcode. It lets you
build localized and non-localized plist files from plc and ploc source
files. These are the property list files found in packages applications,
bundles, frameworks, plugins, etc.


It is modelled on the CodeWarrior property list language: the idea of
preparing source files and compiling them during the build process was
introduced in CodeWarrior Pro 8. The language used in these source files
lets you have the compiler build the property list files for you
automatically, substituting the right values during the building process,
instead of having to manage manually hard-coded XML files. CodeWarrior Pro 
8 introduced a first draft of the plc language together with a dedicated 
compiler written by Josef W. Wankerl. Unfortunately Xcode does not offer 
such a handy tool. Here comes ((b PList Compiler b))!

It is a shell script, named ((b plcompile b)), which is meant to be executed during a Shell Script
Build Phase within an Xcode project. It can also be run directly as a
command line tool if you need to work only with plc files independently 
from the rest of your project.

((b PList Compiler b)) uses the same syntax as the original CodeWarrior 
compiler it supports most of its functionalities and adds many more to take 
advantage of all the Xcode settings.

((b PList Compiler b)) is written in fact in ((b Tcl b)) 
(the ((lk http://wiki.tcl.tk/ )) Tool Command Language lk))): 
the executable script is a ((i bash i)) script called ((b plcompile b)) which magically redirects the
instructions to ((i tclsh i)) which is the Tcl shell. Tcl is installed by
default on OSX since version 10.3 (aka Panther) so ((i tclsh i)) is
normally present on every MacOSX system starting from this version, and 
there should be nothing special to do for this script to run there. For
version 10.2 systems (aka Jaguar), you will have to install Tcl on your
machine: you can, for instance, get Daniel Steffen's Tcl Batteries Included distribution 
((lk http://www.maths.mq.edu.au/~steffen/tcltk/ )) from there. lk))

((b PList Compiler b)) comes with the same BSD license as Tcl itself. 
See the file ((i License_terms i)) included in this distribution or the 
((lk http://www.opensource.org/licenses/bsd-license )) Open Source Initiative (OSI) site lk)).


((s1 Usage

The syntax of the ((b plcompile b)) shell script is:
((|
    plcompile options plcFile
    plcompile (-help | -encoding | -version)
|))

The first form executes the compilation of the plc source file ((i plcFile i)). 
Traditionnally these files have a ((i .plc i)) extension but this is not 
required at all. Most of the time you will not have to worry about the 
options. ((b PList Compiler b)) comes with reasonable defaults for the 
optional values, corresponding to a normal usage of these files in a 
project. The available options are explained below.

In the second form
((|
    plcompile -help
    plcompile -encoding
    plcompile -version
|))
the script prints some help in the console window: with ((i -help i)), you
get the usage string and a reminder of the defaults; with ((i -encoding i)), 
you get a list of the available encodings; with ((i -version i)), you get
the current version number of the script. Note that one can use 
abbreviated flags like ((i -h i)) or ((i -v i)) 
for instance.


((s2 Default behavior
By default, ((b plcompile b)) assumes that the input files are encoded in
MacRoman and have Mac line endings (((i cr i))). The same type of line
endings is used to write the output files but the encoding, this time, is the
Unicode utf-8 form. 

The default destination folder depends on how you execute the compiler:
((lu
((li if you run the script from Xcode as a ((i Shell Script phase i)) (this
is the recommended way), the destination folder depends on the kind of
product you are building: it is the ((i Contents i)) folder inside the
application bundle when you are building a packaged application; in the
case of a framework, it is the ((i Resources i)) subfolder of the
framework ;
((li otherwise it is the same folder as the plc file being processed.
lu))


These are default behaviors which can be modified with options on the 
command line or pragmas in the source files. See the
((rf locout )) Location of the output files rf)) section below.


((s2 Command line options

The complete syntax to run the compiler is:
((|
    plcompile [-input_encoding enc] [-output_encoding enc] [-input_eol eol] 
              [-output_eol eol] [-dest folder] [-o name] [-plist version] 
              [-prefix file] [-Dmacro[=value]]... [-pkginfo] [-I path]... plcFile
|))

The options have the following meaning:
((lu
((li the ((i -input_encoding i)) option lets you specify in which encoding the 
source file should be read (by default ((i macRoman i)));

((li the ((i -output_encoding i)) option  lets you specify in which encoding the 
output files should be written (by default ((i utf-8 i)));

((li the ((i -input_eol i)) option lets you specify the type of line endings used in the
source file (((i cr i)) for Mac, ((i lf i)) for Unix and ((i crlf i)) for Windows);

((li the ((i -output_eol i)) option lets you specify the type of line endings used in
the output files;

((li the ((i -dest i)) option lets you specify a destination folder relatively to which
the output files will be produced. See the
((rf locout )) Location of the output files rf)) section below. Various
pragmas can also be used to specify different subfolders inside the
destination folder.

((li the ((i -o i)) option lets you specify a name for the output
file (instead of the default ((i Info.plist i))) which will be appended to 
the path of the output folder. See the
((rf locout )) Location of the output files rf)) section below.

As a convenience, a string starting with a slash is considered a full path:
this is equivalent to setting both the output file and the output folder.
For clarity though, it is recommended to use the ((i -dest i)) option when
you need to specify a destination folder and use the ((i -o i)) option only
to specify the name.

((li the ((i -plist i)) option lets you specify the version of the plist
XML format (0.9 or 1.0). The default value is 1.0.

((li the ((i -pkginfo i)) option asks ((i PList Compiler i)) to also
generate a ((i PkgInfo i)) file in the same folder as the ((i Info.plist i)) 
file. See the ((rf pkginfo )) Pkginfo file rf)) section below.

((li the ((i -prefix i)) option asks ((i PList Compiler i)) to read a 
prefix file before starting its processing. The prefix file should contain 
only preprocessor macro declarations and pragmas which can be understood by the 
compiler. The file path specified by this option can be either absolute or 
relative to the current working directory.

((li the ((i -D i)) option lets you define preprocessor macros directly
from the command line (rather than with a ((i #define i)) instruction in
the ((i plc i)) file). The syntax is exactly the same as with compilers
like ((b cc b)) or ((b gcc b)): either ((i -Dmacro i)) to simply define a
macro or ((i -Dmacro=value i)) to define it and attribute a value. There
can be as many ((i -D i)) options as necessary.

((li the ((i -I i)) option lets you define additional search paths to
resolve ((i #include i)) directives. ((b PList Compiler b)) builds a list
of search paths by first reading the ((v HEADER_SEARCH_PATHS v)) and
((v USER_HEADER_SEARCH_PATHS v)) Xcode variables and then appending any
path specified by an ((i -I i)) option. There can be as many ((i -I i))
options as necessary.

lu))

!! !! ===================================
((if $aida_target eq "Html" || $aida_target eq "SplitHtml"
!! !! ===================================
((b Note: b)) 
((lu
((li the ((i -pkginfo i)) option has been introduced in version 0.2 of ((i PList Compiler i))
by ((lk mailto:franz.detro@native-instruments.de )) Franz Detro lk)) (thanks).
((li the ((i -o i)) option has been introduced in version 0.5. This is 
patch 1474228 contributed by 
((lk mailto:jmiltner@users.sourceforge.net )) Jens Miltner lk)) (thanks).
((li the ((i -prefix i)) option has been introduced in version 0.5. It is a
feature request made in the 
((lk http://sourceforge.net/tracker/?group_id=149940 )) ((i PList Compiler i)) tracker lk))
at SourceForge (RFE 1461559).
((li the ((i -D i)) option has been introduced in version 0.6. It is a
feature request made privately.
((li the ((i -I i)) option has been introduced in version 0.6. It is 
a code contribution by 
((lk mailto:jmiltner@users.sourceforge.net )) Jens Miltner lk)) (thanks).
lu))
!! !! ===================================
if))
!! !! ===================================


((s1 Howto

((s2 Using PList Compiler in an Xcode project

The idea is to generate the various plist files and localized strings
files during a ((i Shell Script Build Phase i)) within your Xcode project. 
Xcode lets you define ((i Shell Script Build Phases i)): they are shell
scripts which can be executed at any stage of the building process. 

So, in order to use ((b PList Compiler b)) from Xcode, you would normally create, in
all the targets for which you want plist files to be generated, a build phase
which could take place at the end of the build process. To create a 
((i Shell Script Build Phase i)), select the target you want in the ((i Groups
and Files i)) panel of your main project window and select the ((i Shell
Script Build Phase i)) command in the ((i New Build Phase i)) submenu of
the ((i Project i)) menu. If you open the disclosure triangle located in 
front of the target's name, you will see your new shell phase (in Xcode 2.1, 
it is called ((i Run Script i))). Select it and click on the ((i Info i)) button 
in the toolbar (or select ((i Get Info i)) in the ((i File i)) menu).

Xcode displays a window in which you can enter shell commands to execute. 
If your plc file is named MyApp.plc, you should just have to enter a 
command like
((|
    plcompile /path/to/MyApp.plc
|))
The only point is to make sure that the shell (Bash shell) can find the 
((b plcompile b)) script. This depends on where you have put this script on your 
machine. If it is in one of the folders of your shell ((v PATH v)) 
variable, there should be no problem. Otherwise you can specify the
complete path of the script, like for instance:
((|
        /Users/bernardo/Devel/Tools/plcompile   /path/to/MyApp.plc
|))
or alternatively change the directory to this directory and execute the 
script there, like this:
((|
        cd /Users/bernardo/Devel/Tools
        ./plcompile  /path/to/MyApp.plc
|))
supposing, in the previous example, that ((b plcompile b)) resides in ((i /Users/bernardo/Devel/Tools i)).

((nl Since version 0.6, ((b PList Compiler b)) supports symbolic links to
designate the plc file. This also applies to prefix files specified with
the ((i -prefix i)) option. Note that this concerns Unix symbolic links
(created with the ((i ln i)) command) but not Finder aliases.


((s2 Using PList Compiler in Terminal

The ((i plcompile i)) script can be used directly from the command line (in
a Terminal window). There is only one caveat with this approach: only the
environment variables defined in the current shell window are available.
This means that you must make sure, if ever your plc file makes use of
environment variables defined by Xcode, that they are available in the
shell. You could have to define them manually. If your plc file does not
need any of the values set by Xcode, then you should normally be able to
compile your plc files directly. You will probably want, in that case, to
specify a destination folder using the ((i -dest i)) command line option.

For instance:
((|
    /Developer/Tools/plcompile -dest ~/Devel/Tests myfile.plc
|))


((s2 Troubleshooting

In case the instructions above do not work as expected, here are a few 
indications to help solving the problem.
 
Make sure that the plcompile script has been saved with Unix line endings
(lf) rather than Mac line endings (cr). Some editors tend to change them 
in your back and the shell expects Unix line endings.

Make sure there is not an already existing ((i Info.plist i)) file in your source 
files added to your built product during the ((i Copy Bundle Resources i)) 
phase in order to avoid conflicts or files being overwritten.

Make sure, in the target settings, that no file has been declared in 
the ((i Info.plist File i)) setting (look in the ((i Packaging i)) section of the 
((i General i)) settings).

Make sure of course that Tcl is installed on your machine. It is part of 
the Panther and Tiger installation.

If you are having trouble with the encodings, it is maybe because the text 
editor you used to create the ((i .plc i)) source files saved your files in 
utf-8. If your source file is utf-8 encoded, you will have to tell 
((b plcompile b)) and specify the ((i -input_encoding i)) option, like this:
((|
    ./plcompile -input_encoding utf-8 /path/to/MyApp.plc
|))
Once again, the default is to read the source files in macRoman and to
write the output files in utf-8.

Make sure you used the proper casing to specify the encodings: it is ((i
macRoman i)) and not ((i MacRoman i)), ((i utf-8 i)) and not ((i UTF-8 i)).
If you have a doubt, execute the following command which returns the list
of all the available encodings:
((|
    plcompile -encoding
|))

If the script is not found by the shell, read the informations in the 
section above about executing shell phases in Xcode and setting the access 
paths correctly.


((s1 Anatomy of 'plc' files

The ((i .plc i)) source files are regular text files taken as input by
((b PList Compiler b)) in order to produce one or several output files.
They contain three types of commands:
((lu
((li preprocessor macros, simlar to those found in C or C++ source files;
((li specific commands understood and interpreted by the compiler;
((li comments ignored by the compiler.
lu))


((s2 Comments

((b PList Compiler b)) recognizes two kinds of comments: the C-like
comments enclosed between /* and */ which can span multiple lines, and, on
a single line, portions of text starting with a double slash (//) up to the
end of the line.

((nl Be careful with the latter because the compiler is moderately clever
to detect these symbols when they are found inside a quoted string (in
which case you would not like them to be considered as a comment and wiped
out!). The heuristics is as follows: if a line starts with // it is
deleted unconditionnally but, if the // is not at the beginning of the
line, it is considered as a comment only if there is no double quote after
it, otherwise it might be a double slash inside a quoted string. This has 
been fixed in version 0.5: previous versions failed when a string 
contained a double slash.


((s2 The plc commands

Most of these commands correspond to an XML entity in the output ((i Info.plist i))
file. An ((i Info.plist i)) file is an XML document. The format of the plist files
is specified by Apple in a DTD which can be found in 
((i /System/Library/DTDs/PropertyList.dtd i)).
For a detailed description of property list files, see for instance
((lk http://developer.apple.com/documentation/CoreFoundation/Conceptual/CFPropertyLists/index.html )) Introduction to Property Lists lk))

All the commands must be kept on a separate line (but not necessarily at
the beginning of the line). Since version 0.6, one can use a backslash at
the end of a line as a line continuator. If a backslash is found as the
last character of a line, it is interpreted as a line continuation
character: it is removed and the next line is concatenated to the previous
one after any initial spaces have been trimmed. This can be useful in order
to break very long strings on several lines.


((s3 The 'plist' command

The first command found in a ((i .plc i)) file designed to generate a .plist file
is always the ((i plist i)) command. Its argument is a block enclosed
inside a pair of curly braces. A minimal property list file,
describing a completely empty property list, would look like this:
((|
    plist {}
|))

The ((i plist i)) command corresponds to the <plist> XML tag.


((s3 The 'dictionary' command

Directly inside the ((i plist i)) block, there is usually a ((i dictionary i)) 
command. This is not required by the DTD but all property lists in use are
structured like this. Like with the ((i plist i)) command, the argument of a
((i dictionary i)) command is a block enclosed inside a pair of curly
braces. So, a minimal valid plc source file would be:
((|
    plist
    {
        dictionary {}
    }
|))

The ((i dictionary i)) command corresponds to the <dict> XML tag.

The dictionary is made up of key/value pairs. The key names must be unique within a single
dictionary. The value of a key can have any of the following types: ((i array, boolean,
data, date, dictionary, number, i)) or ((i string i)).


((s3 The 'key' command

The key/value pairs are declared by instructions in the following format
((|
    key "name_of_the_key" value "type_of_value" "the_value"
|))

In this instruction, the ((i key i)) and  ((i value i)) keywords correspond
to the <key> and <value>  XML tags respectively.

For instance, here is a valid key statement in a dictionary block:
((|
    key "Victor Hugo" value string "Writer"
|))


((s3 The 'array' command

The ((i array i)) command is used to describe an ordered list of property list elements.
These elements can be of any of the abovementioned types ((i (array, boolean,
data, date, dictionary, number, string). i))

The original specification of the plc syntax in CodeWarrior stipulated that
the argument of an ((i array i)) command is a block enclosed inside a pair
of square brackets. With ((b PList Compiler b)), you can also use curly braces
instead of square brackets.

Here is an example of an array containing a dictionary and a boolean value:
((|
    array
    {
        boolean true
        dictionary {
            key "Victor Hugo" value string "Writer"
            key "Ludwig van Beethoven" value string "Composer"
        }
    }
|))


((s3 The 'string' command

The ((i string i)) command lets you specify a string value. Strings are
enclosed in double quotes in order to distinguish them
from a substitutable variable (see below), but this is not required. If
there is no risk of ambiguity, you can suppress the quotes. Still it
is good programming practice to write them.

The value of a string can be made up of several pieces, mixing quoted strings or 
variables. For instance:
((|
    string "copyright (c) " __YEAR__ ", all rights reserved" 
|))
where ((v __YEAR__ v)) is one of the predefined variables set by the 
compiler. This string will be expanded to something like 
((i copyright (c) 2005, all rights reserved i)).
The ((i string i)) command corresponds to the <string> XML tag.

((b Caveat: b)) in order to ensure a better compatibility with the
CodeWarrior property list compiler which accepted both ((i single i)) and
((i double i)) quotes to delimit strings, PList Compiler does its best to
support the same convention. For instance:
((|
    string 'RSRC'
|))
will produce ((i <string>RSRC</string> i)) as it did with the CodeWarrior
property list compiler. As a consequence, this makes it a little more
difficult to obtain values enclosed in quotes in the output file. For
instance, if you really want to get a string value like 'RSRC' or "RSRC"
(including the quotes), you will have to code it like this:
((|
    string "'RSRC'"
    string "\"" RSRC "\""
|))
Be also aware that, in the case where you concatenate several strings or
mix strings and variables, single quotes will confuse the compiler and the
odds are very high that you won't obtain what you expect, so your best bet
is to always use double quotes (and no quotes at all for substitutable
variables).

Since version 0.4, the ((i ampersand, greater-than, less-than, quote i))
and ((i apostroph i)) symbols are correctly converted into XML entities
(like ((v & v))((v amp; v)) etc.) in order to ensure the well-formedness of
the output file. Since version 0.5, the ((i escape_entities i)) pragma
gives you entire control about this (see the ((rf pragma )) Pragmas section rf)) 
below).

!! !! Similarly, whitespace characters must be escaped. If you write 
!! !! ((|
!! !! 	string 'TCL '
!! !! |))
!! !! you will get ((i <string>'TCL'</string> i)) (with single quotes and no
!! !! whitespace!) which is probably not what you want. This is because, in that 
!! !! example, the compiler sees two unquoted strings: the first is ((i 'TCL i))
!! !! and the second is an isolated single quote. In order to get 
!! !! ((i <string>TCL </string> i)), you must write:
!! !! ((|
!! !! 	string 'TCL\ '
!! !! |))

((s3 The 'number' command

The ((i number i)) command lets you specify numeric values. There is no 
XML tag named ((i number i)) in a plist file, but rather two entities named 
<real> and <integer> corresponding 
respectively to integer or floating point values. The ((i number i)) 
command corresponds to both of them: the compiler automatically decides to 
which type the value belongs. For instance, the following declarations will 
result in an <integer> tag:
((|
    number 0
    number 1
    number -1
|))
while the following ones will yield <real> tags:
((|
    number 0.0
    number 3.14
    number -2.718
    number .1
    number -.1
    number 6.09e23
|))


((s3 The 'date' command

The ((i date i)) command lets you specify a date value. The plist format 
specification (in ((i /System/Library/DTDs/PropertyList.dtd i))) suggests 
that:
((q "the contents of a date value should conform to a subset of ISO 8601:
in particular, YYYY '-' MM '-' DD 'T' HH ':' MM ':' SS 'Z'. Smaller units
may be omitted with a loss of precision." q))

For instance:
((|
    date "2005-09-15 18:06:03"
    date "2005-09-15T18:06:03Z"
    date __DATE__
|))
where ((v __DATE__ v)) is one of the predefined variables set by the compiler.
The ((i date i)) command corresponds to the <date> XML tag.


((s3 The 'data' command

The ((i data i)) command is used to store raw binary data. The value of a
data type is expressed in the plc file in hexadecimal format, possibly with
space characters, like for instance:
((|
    data "64656667"
    data "64 65 66 67"
    data "64 65"  "66 67"
|))
In the output file, the same data is represented in Base64 encoding as 
recommended in the DTD specifying the plist format 
(see ((i /System/Library/DTDs/PropertyList.dtd i))). All the 
values above are equivalent and are represented like this in Base64 
encoding:
((nl <data>ZGVmZw==</data>

The ((i data i)) command corresponds to the <data> XML tag.

((b Note: b)) the CodeWarrior plist compiler also defined a ((i data file
i)) command followed by the name of a file containing raw data. This is not
implemented by ((b PList Compiler b)) as of version 0.1.



((s3 The 'boolean' command

The ((i boolean i)) command lets you specify a boolean value using any of
the usual keywords: true/false, yes/no, and 1/0. Casing does not matter, so
TRUE, true or True are all acceptable values. The value can be enclosed in
double quotes but this is not required.

For example:
((|
    key "kGcc_Precompile_Prefix_Header" value boolean 1
    key "kGcc_Symbols_Private_Extern" value boolean 0
    key "kGenerate_Profiling_Code" value boolean Yes
    key "kUse_Dynamic_No_Pic" value boolean "false"
    key "kZero_Link" value string __ZERO_LINK__
|))

The last example is correct because Xcode defines a ZERO_LINK variable 
whose value can be either "YES" or "NO" (see below).

The ((i boolean i)) command corresponds to the <boolean> XML tag.


((s2 Localized files

The localized files contain lists of keyed strings localized for a particular 
language.

((s3 The 'localize' command

The ((i localize i)) command is used to create and generate localized strings files. It is a 
top level command like the ((i plist i)) command. There are two possible 
syntaxes to invoke this command:
((|
    localize "language"
    localize "language" as "localized_file_name"
|))

The first form is used to localize string values present in the main property list
dictionary of the ((i plist i)) command. The resulting file is named by 
default
((i InfoPlist.strings i)) instead of ((i Info.plist i)), and is located inside the 
localized folder corresponding to the specified language instead of the 
((i Contents i)) folder. For instance:
((|
    /Contents/Resources/Spanish.lproj/InfoPlist.strings
|))

The second form of the ((i localize i)) command specifies the name of the generated
file rather than relying on the default name. This allows to create several
separate strings files. These files will also be created in
the folder corresponding to the specified language.

The argument of the ((i localize i)) command is a block enclosed in a pair of 
curly braces. Only two commands can be used inside a localize block: ((i key i)) 
and ((i comment i)). The ((i key i)) command defines key/value statements of type ((i string i)). 
For instance:
((|
    localize "French"
    {
        key "CFBundleGetInfoString" value string "MyApp, (c) 2005, tous droits réservés"
        key "CFBundleHelpBookName" value string "Aide PList Compiler"
    }
    
    localize "Spanish" as "Dialogs.strings"
    {
        key "Number of Recent Items:" value string "Número de ítems recientes:"
        key "General Preference Pane" value string "Panel de preferencias General"
    }
|))
The first instruction generates 
((i MyApp.app/Contents/Resources/French.lproj/InfoPlist.strings i))
and the second one
((i MyApp.app/Contents/Resources/Spanish.lproj/Dialogs.strings i))

It is current practice to put the ((i localize i)) blocks in separate files and 
use a ((i .ploc i)) extension in their name to distinguish them from the ((i .plc i)) 
files. The ((i .ploc i)) files are usually invoked from the main ((i .plc i)) file with an 
((v #include v)) preprocessor command. For instance:
((|
    #include "DialogStrings_Spanish.ploc"
|))


((s3 The 'comment' command

The ((i comment i)) command lets you insert comments inside the localized
strings files. There can be as many commands of this type in a ((i localize
i)) block as necessary. The value of the command is a string or
concatenation of strings and expandable variables: once concatenated and
substituted, it is inserted inside a C-like comment of the form 
((v /* */ v)) in the output file.
For instance, the following instruction might be found in some ((i .ploc
i)) file:
((|
    localize "English" as "Dialogs.strings"
    {
        comment "Generated from " __FILE__ " at " __TIME__
    }
|))

The ((v __FILE__ v)) and the ((v __TIME__ v)) symbols used in this example are predefined variables: ((v __FILE__ v)) 
always contains the name of the file being currently processed by the 
compiler and ((v __TIME__ v)) the time at the moment the compiler processes the 
file. If the instruction above was stored in a file named 
((i dialogStrings_EN.ploc i)), the comment generated in the resulting ((i 
Dialogs.strings i)) file (in the ((i /Contents/Resources/English.lproj i))
folder inside the bundle) would look like this:
((|
    /* Generated from dialogStrings_EN.ploc at 23:54:25 */
|))

((b Caveat: b)) the ((i comment i)) command can't be used in a ((i plist i)) block.

((a locout )) a))
((s1 Location of the output files

By default, the ((i plist i)) command causes ((b PList Compiler b)) to
create a file named by defult ((i Info.plist i)) inside the destination
directory. In the case of a packaged application, the default destination
directory is the ((i Contents i)) folder inside the bundle. More generally,
the path of this destination folder is built by ((b PList Compiler b))
using the values of the ((v TARGET_BUILD_DIR v)) and ((v INFOPLIST_PATH v))
Xcode variables.

For instance, with Xcode 2.1, if your target is in the ((i Release i))
configuration and your application is MyApp, the destination folder would
be (unless you have non standard settings):
((|
    $SRCROOT/build/Release/MyApp.app/Contents 
|))
where ((v SRCROOT v)) is, as usual the folder containing your project file.

The ((i localize i)) command causes ((b PList Compiler b)) to
create localized files. The default location for these files depends on the
language used for the localization. In the case of a packaged application,
the default destination is inside one of the ((i /Contents/Resources/<language>.lproj i))
subfolders of the bundle. For instance ((i /Contents/Resources/English.lproj i)) or
((i /Contents/Resources/French.lproj i)).

There are two ways of modifying the destination folders:
((lu
((li from the command line, using the ((i -dest i)) option
((li using one of the ((i in_package_directory i)) or ((i localize_directory i)) pragmas (see below)
lu))

The output file name (usually ((i Info.plist i))) can be modified inside
the ((i plc i)) file using the ((i output_filename i)) pragma: see the 
((rf pragma )) ((i Pragmas i)) section rf)) below. It can also be specified
directly from the command line via the ((i -o i)) option (introduced in
version 0.5 of ((i Plist Compiler i))).


((s1 Preprocessor directives

This is the other type of instruction found in plc source files. They are called preprocessor directives 
by analogy with the C/C++ language.
They are also sometimes refered to as preprocessor macros. The 
preprocessor term is not quite accurate here 
because there are not two phases like with the ordinary C compilers (a 
preprocessing phase and a compiling phase): ((b PList Compiler b)) parses 
the file once, line by line.

The following macros are supported by ((b PList Compiler b)):
((i #define, #message, #if, #elif, #include, #warning, #ifdef, #else,
#pragma, #error, #ifndef, #endif i))


((nl Preprocessor directives all occur on their own line. They are characterized
by the fact that the first non-whitespace character on the line is a #. 
There may be whitespace characters between the # mark and the name of the 
directive too.

((s2 Defines
The ((i #define i)) directive lets you define a macro in the property list compiler.  The
format is:
((|
    #define macro_name macro_text
|))

The compiler adds the macro ((i macro_name i)) to its macro table: if 
there is already a macro with this name, it emits an error. When ((i macro_name i))
appears in a plc source file as the value of a string type not 
enclosed between double quotes, it is automatically replaced by
((i macro_text i)).

For instance, if a macro ((i kVersionNumber i)) is defined like this:
((|
    #define kVersionNumber "1.2.3"
|))
then, when the compiler encounters the following instruction:
((|
    key "CFBundleShortVersionString" value string "kVersionNumber: " kVersionNumber
|))
it expands it to ((i kVersionNumber: 1.2.3 i))

The ((i #undef i)) directive tells the compiler to remove an already 
existing macro from its macro table. The syntax is:
((|
    #undef macro_name
|))
If ((i macro_name i)) does not exist, the directive is just ignored.

((b Note: b)) the same remarks as with the ((i string i)) keyword apply
here concerning the use of single quotes as string delimiters. They are
supported in the case of simple string values but not in concatenations.
Use double quotes to be safe.


((s2 Includes
The ((i #include i)) directive tells the plist compiler to find another plc
source file and start processing it. The syntax of this directive has two
forms:
((nl #include "filename"
((nl #include <filename>

The two forms are not equivalent: the difference is explained below. The
((i filename i)) value designates a file to include: it can be either an
absolute or a relative path. A relative path is resolved by searching
relatively to various folders: 
((lu

((li in the first form, ((b PList Compiler b)) will first try to resolve
the path relatively to the folder containing the parent source file (i-e,
the file which invokes the ((i #include i)) directive). If this fails, it
will try all the header search paths: these are the paths defined in the
Xcode's ((v HEADER_SEARCH_PATHS v)) variable and any path specified on the
command line using an ((i -I i)) option.

((li in the second form, where the file name is enclosed in angle brackets,
only the header search paths are searched.

lu))
 
The following are all valid examples (the double quotes are necessary only 
if the filename contains space characters):
((|
    #include /Users/bernardo/Devel/MyApp/Rsrc/OtherFile.plc
    #include OtherFile.plc
    #include "LocFiles/My Strings_EN.ploc"
    #include "../Rsrc/My Strings_EN.ploc"
|))

It is also possible to specify a path using a substitutable variable. Here
is an example:
((|
    #define CURRENT_LOCALE "EN"
    #include "Strings_" CURRENT_LOCALE ".ploc"
|))

!! !! ===================================
((if $aida_target eq "Html" || $aida_target eq "SplitHtml"
!! !! ===================================
((b Note: b)) the second form of the ((i #include i)) directive is a code
contribution by 
((lk mailto:franz.detro@native-instruments.de )) Franz Detro lk)) (thanks) 
introduced in version 0.2 of ((b PList
Compiler b)). The support for substitutable variables in #include paths is
a code contribution by 
((lk mailto:stevec@shoutingmime.com )) Steve Christensen lk)) (thanks) 
introduced in version 0.6 of ((b PList
Compiler b)).
!! !! ===================================
if))
!! !! ===================================


((s2 Conditional macros

((b PList Compiler b)) supports the following six conditional directives:
((i #if i)), ((i #ifdef i)), ((i #ifndef i)), ((i #elif i)), 
((i #else i)), ((i #endif i)) 
which let you build
conditional blocks of instructions depending on the value of a test
expression or on the existence or non-existence of a particular variable.

The ((i #ifdef i)) directive tests for the definition of a compiler macro, while
the ((i #ifndef i)) directive tests for the non-definition of this macro. Their
behavior is the opposite of one another. In the case of ((i #ifdef i)) for
instance, if the macro has been previously defined, the property list code
immediately following the ((i #ifdef i)) directive is processed until an ((i #else i)) or
((i #endif i)) directive is encountered, but on the contrary, if the macro has not been defined,
the property list code immediately following the ((i #ifdef i)) directive is not
processed. In that case, if there is an ((i #else i)) directive, instead the code
following this ((i #else i)) is processed until the matching ((i #endif i)) directive is
found.

Similarly, if the expression in an ((i #if i)) directive evaluates to 1, the
instructions immediately following the ((i #if i)) directive are executed until an
((i #else i)), ((i #elif i)), or ((i #endif i)) directive is encountered. If the expression
evaluates to 0, the property list code immediately following the ((i #if i))
directive is not processed.

Each ((i #if i)), ((i #ifdef i)), ((i #ifndef i)) directive must be matched by an ((i #endif i)) directive.

The ((i #elif i)) directive allows for multiple successive ((i #if i)) tests during the
preprocessing stage. An ((i #elif i)) test is evaluated only if all the preceding
tests have failed.

Here are a few examples of conditional constructs. Other more advanced 
technics involving Tcl instructions are explained in the section 
((rf advanced )) Advanced topics rf)).


((s3 Example 1
Note in this example that for testing equality you must use a double 
equal sign (==). A single equal sign would provoke an error.
((|
    #define kVersionFive 5
    #define kVersionSeven 7
    #define kCurrentVersion kVersionFive
    
    #if kCurrentVersion == kVersionSeven 
        #warning "Current version is " kVersionSeven
    #else
        #warning "Current version is not " kVersionSeven    
    #endif
|))


((s3 Example 2

When testing a condition involving a string value, one must take care of
properly quoting the strings. Here is an example 
(where ((i DEBUGGING_SYMBOLS i)) is an Xcode variable whose value 
is ((i YES i)) or ((i NO i))):
!! !! ===================================
((if $aida_target eq "Html" || $aida_target eq "SplitHtml"
!! !! ===================================
((|
    #if DEBUGGING_SYMBOLS == \"YES\"
        #warning "debugging symbols are enabled"
    #endif
|))
!! !! ===================================
if))
!! !! ===================================
!! !! ===================================
((if $aida_target eq "Man"
!! !! ===================================
!! !! Double backslash needed for man page
((|
	#if DEBUGGING_SYMBOLS == \\"YES\\"
		#warning "debugging symbols are enabled"
	#endif
|))
!! !! ===================================
if))
!! !! ===================================
It is not sufficient to just enclose the string ((i YES i)) in double
quotes (because of double parsing, first by the preprocessor, then by the
interpreter). Another possible syntax is:
((|
    #if DEBUGGING_SYMBOLS == {"YES"}
        #warning "debugging symbols are enabled"
    #endif
|))


((s3 Example 3
This example demonstrates nested conditional blocks.
((|
    #define kVersionFive 5
    #define kVersionSix 6
    #define kVersionSeven 7
    #define kCurrentVersion kVersionSeven
    
    #if kCurrentVersion == kVersionSeven 
        #warning "Current version is " kVersionSeven
    #else
        #if kCurrentVersion <= kVersionFive 
            #warning "Current version <= " kVersionFive
        #else
            #warning "Current version > " kVersionFive
        #endif
        #warning "Done comparison with kVersionFive"
    #endif
|))


((s3 Example 4
Here is an example using ((i #ifdef i)) and ((i #ifndef i)) directives:
((|
    #undef kUndefinedMacro
    #ifdef kUndefinedMacro
    #    define kWillNeverBeDefinedMacro
    #endif
    
    #ifndef kWillNeverBeDefinedMacro
    #    define kHasNotBeenDefined "No, it has not been defined"
    #else
    #    define kHasBeenDefined "Yes, it has been defined"
    #endif
|))


((s3 Example 5
Here is an example using the ((i #elif i)) directive:
((|
    #define kVersionFive 5
    #define kVersionSix 6
    #define kVersionSeven 7
    #define kVersionEight 8
    #define kCurrentVersion kVersionSix
    #if kCurrentVersion <= kVersionFive 
        #warning "Current version is <= " kVersionFive
    #elif kCurrentVersion <= kVersionEight 
        #if kCurrentVersion == kVersionSix
            #warning "Current version is " kVersionSix
        #elif kCurrentVersion == kVersionSeven 
            #if kCurrentVersion < 0
                #warning "Current version is negative!"
            #elif kCurrentVersion > 10
                #warning "Current version is > 10"
            #else
                #warning "Current version is between 1 and 10"
            #endif
        #else
            #warning "Current version is " kVersionEight
        #endif
    #else
        #warning "Current version is > " kVersionEight
    #endif
|))


((s2 Errors and warnings

The ((i #error i)) directive raises an error and stops the execution of the
compiler. This is generally used in combination with ((i #if i)) directives
to test for situations that should never occur.

The ((i #warning i)) and ((i #message i)) directives send a message to the
console: the text of the message is prepended by the word ((i Warning: i))
or ((i Message: i)) respectively.

Here are a few examples:
((|
    #warning "Fix the version number before shipping"
    #message "PList Compiler is great!!!"
    #if __PLIST__ < 1.0
       #error "The property list version is too old"
    #endif
|))

((a pragma )) a))
((s2 Pragmas

Pragmas are directives used to modify the internal state of the compiler. 
They let you modify some internal settings during the execution of the plc 
file. They are most useful to modify locally a global setting: the new 
value set by a pragma holds until another pragma modifies it again. 
A pragma is declared with the ((i #pragma i)) directive. The syntax is:
((|
    #pragma pragma_name [pragma_value]
|))

The supported pragmas are explained below. The ((i pragma_name i)) argument
can be one of the following keywords:
((i output_filename,
in_package_directory,
localize_directory,
output_eol,
output_encoding,
plist_version,
escape_entities. i))

Any other pragma encountered will be simply ignored by ((b PList Compiler
b)). In particular the ((i once i)), ((i notonce i)), and ((i mark i))
pragmas, defined by the CodeWarrior compiler, are not supported, as of
version 0.1.

((b Caution: b)) a pragma cannot be used inside a ((i plist i)) or a 
((i localize i)) block. It must be invoked outside these environments. This
is because the internal settings they affect can't be modified once a file
has been opened for output. The compiler will emit an error if such a 
situation occurs.


((s3 The 'output_filename' pragma
The ((i output_filename i)) pragma lets you override the default name 
of the current output file. Its value is a string which is the new name. 
For instance:
((|
    #pragma output_filename "OtherName.plist"
|))

The new name given with this pragma is used only once and then
forgotten, so that the compiler immediately returns to the default naming convention. 
Note that this does not affect the filename defined in a  'localize as' 
command. More precisely, if the compiler reads the following inxtructions:
((|
    #pragma output_filename "OtherName.txt"
    localize "Spanish" as "Error.strings"
    {
    }
|))
the pragma will have no effect and the output file will still be named 
((i Error.strings i)). On the other hand, the pragma will remain in effect 
until it can be applied. 


((s3 The 'in_package_directory' pragma
The ((i in_package_directory i)) pragma lets you specify where to place the
property list file inside the destination folder. It is a string which
specifies a directory ((i relative i)) to the destination folder. For instance, if
you write:
((|
    #pragma in_package_directory "Infos"
|))
the ((i Info.plist i)) file will be written in an ((i Infos i)) subfolder
of the destination folder rather than in the destination folder directly.
If the subfolder does not exist, it is created. By default, this will be
((i MyApp.app/Contents/Infos i)) (unless another destination folder has 
been otherwise specified).

Another valid value for this pragma could be:
((|
    #pragma in_package_directory "../Infos/Properties"
|))
which would write the output file in ((i MyApp.app/Infos/Properties i)),
i-e with the ((i Infos i)) directory at the same level as the 
((i Contents i)) directory.


((s3 The 'localize_directory' pragma
While the previous pragma affected the final location of the ((i Info.plist i))
files (produced by the ((i plist i)) command), the ((i localize_directory i))
pragma lets you specify where to place the localized strings files produced
by the ((i localize i)) command. It is a string which specifies a directory
((i relative i)) to the destination folder. By default, it is the ((i Resources i))
folder inside the destination folder which itself is, by default, the
((i Contents i)) subfolder of the bundle. For instance:
((|
    #pragma localize_directory "Local/Strings/"
|))
will cause the localized strings files to be written in some 
((i MyApp.app/Contents/Local/Strings/<language>.lproj i)) folder 
(depending on the chosen language) instead of 
((i MyApp.app/Contents/Resources/<language>.lproj i)).


((s3 The 'output_eol' pragma
The ((i output_eol i)) pragma lets you specify another type of line endings
for the output files. The possible values are ((i cr i)) for Mac, 
((i lf i)) for Unix and ((i crlf i)) for Windows. This pragma is useful to
override a setting made with the ((i -output_eol i)) option on the command
line of the ((b plcompile b)) shell script.
((|
    #pragma output_eol lf
|))


((s3 The 'output_encoding' pragma
The ((i output_encoding i)) pragma lets you specify another encoding for
the output files. The possible encodings are listed by the command:
((|
    plcompile -encodings
|))
which currently returns:
((nl ((i ((s [join [lsort [encoding names]] ", "] s)) i))

((nl You would normally be interested only in the utf-8 and utf-16 encoding forms 
which are the only encodings recognized for property list files. ((b PList 
Compiler b)) is able though to handle all the other encodings.

This pragma is useful to override a setting made with the 
((i -output_encoding i)) option on the command line of the ((b plcompile b))
shell script. For instance:
((|
    #pragma output_encoding utf-16
|))

Note that there is no equivalent pragma concerning the input encoding
because it does not make sense: the input file would have already been read
when the pragma is encountered.

((s3 The 'plist_version' pragma
The ((i plist_version i)) pragma lets you specify another version of the 
property list format. The possible values currently are 0.9 and 1.0. This is 
the value written in the ((i version i)) attribute of the <plist> tag in the 
((i .plist i)) files. For instance:
((|
    #pragma plist_version 0_9
|))
yields
<plist version="0_9">

This is the same value stored in the ((v __PLIST__ v)) predefined variable
(see below).


((s3 The 'escape_entities' pragma
The ((i escape_entities i)) pragma was introduced in version 0.5: it lets
you specify whether to use the standard XML entities or not.

Since version 0.4, the ((i ampersand, greater-than, less-than, quote i)) and
((i apostroph i)) symbols are automatically converted by ((b PList Compiler b))
into their equivalent XML entities. This pragma allows you to turn this
feature on or off during processing. The possible values are 0 or 1, or
equivalently ((i off i)) or ((i on i)) (default is 1).

For instance, to turn escaping off:
((|
    #pragma escape_entities off
|))


((s1 Substitutable variables

Substitutable variables are variables whose value is inserted when the
script is run. These variables can be defined via a ((i #define i))
preprocessor macro in the plc file, or as a shell variable in the shell
environment, or with the ((i -D i)) option directly on the command line.
There are also some useful predefined variables set by the plc compiler
itself.

Variables defined with a ((i #define i)) macro can be invoked directly. For 
instance, if you define
((|
    #define kBundleShortVersion "1.2.3"
|))
you can then have a key in the ((i plist i)) dictionary declared like this
((|
    key "CFBundleVersion" value string kBundleShortVersion
|))


((b Note: b))
((nl In versions older than 0.6, in order to invoke a variable defined in
the shell environment or inherited from Xcode, one had to surround it with
double underscores (like __USER__ instead of USER). It is not the case
anymore since version 0.6. For backward compatibility, ((b PList Compiler
b)) will still check if a variable surrounded by double underscores is an
inherited variable but you should update your plc files if you were using
this old (and confusing) convention.


((s2 Predefined variables

A few predefined variables are set each time the ((b plcompile b)) script is 
run. 

The five following variables existed in the CodeWarrior property list
compiler. They are still available with ((b PList Compiler b)) in order to
ensure some compatibility with already existing plc files (and because they
are very useful!):
((ld
((lt __FILE__
This variable always contains the name of the file currently processed. If
another file is included with an ((i #include i)) preprocessor macro, the
value of the variable is changed accordingly so that it always designates
the file being processed. 
lt))
((lt __OUTPUT_CREATOR__
This variable contains the creator
type of the built product. It corresponds to the MACOS_CREATOR Xcode variable.
lt))
((lt __OUTPUT_TYPE__
This variable contains the file
type of the built product. It corresponds to the MACOS_TYPE Xcode variable.
lt))
((lt __OUTPUT_FILENAME__
This variable contains the name of the built product. It is equivalent to 
the concatenation of the PRODUCT_NAME and
WRAPPER_EXTENSION Xcode variables.
lt))
((lt __DATE__
This is the complete date at the moment where the script is executed. It is
returned in the format specified by the ISO 8601 standard:
YY-MM-DDTHH:MM:SSZ. For instance ((i "2005-10-04T17:12:23Z" i)).
lt))
ld))
((nl ((b Caveat: b)) one must be aware that the values of the ((v OUTPUT_CREATOR v)) 
and ((v OUTPUT_TYPE v)) predefined variables are taken from the Xcode
variables called ((v MACOS_CREATOR v)) and ((v MACOS_TYPE v)), but that, in
certain circumstances, these variables are not displayed in the ((i Target
Settings i)) panels in ((i Xcode i)). The variables do exist but simply
are not displayed by default.  As a consequence, their value in that case
is empty. This is a problem with ((i Xcode i)), not with ((i PList
Compiler i)). The remedy, should this situation occur, is to add these
variables manually in the ((i Target Settings i)) panel in Xcode using the ((i Plus i))
button and to give them the desired values corresponding to your project.

Furthermore ((b PList Compiler b)) introduces other useful predefined variables: 
((ld
((lt __YEAR__
The current year (four digits)
lt))
((lt __MONTH__
The current month number (01 - 12)
lt))
((lt __MONTHNAME__
The full month name (January, etc.)
lt))
((lt __DAY__
The current day of month (01 - 31)
lt))
((lt __DAYNAME__
The full day name (Monday, etc.)
lt))
((lt __SHORTDATE__
The current date as YYYY-MM-DD.
lt))
((lt __TIME__
The current time as HH:MM::SS.
lt))
((lt __HOURS__
The hours part of the TIME string.
lt))
((lt __MINUTES__
The minutes part of the TIME string.
lt))
((lt __SECONDS__
The seconds part of the TIME string.
lt))
ld))

For instance:
((|
    __DATE__      = 2005-10-04T15:54:36Z
    __SHORTDATE__ = 2005-10-04
    __YEAR__      = 2005
    __MONTH__     = 10
    __MONTHNAME__ = October
    __DAY__       = 04
    __DAYNAME__   = Tuesday
    __TIME__      = 15:54:36
    __HOURS__     = 15
    __MINUTES__   = 54
    __SECONDS__   = 36
|))



((s2 Xcode environment variables

All the environment variables set by an Xcode project are accessible with
((b PList Compiler b)). See the Xcode documentation for a complete list. For instance
((|
    key "InfoPlistPath" value string INFOPLIST_PATH
|))

Some of these variables are set by Xcode itself (they are generally meant
to be read-only variables) while the others can be set in the info window
of a particular target. Tip: the name of a variable corresponding to a
particular setting is always indicated by Xcode between parentheses in the
help text displayed when you select this setting in a Target Info window.

((nl ((b Remark: b)) 
((lo
((li since version 0.6, it is not necessary anymore to enclose inherited
variables in double underscores in order to dereference them. See the note 
above in the ((i Substitutable variables i)) section.

((li one cannot define a macro with the same name as an inherited
environment variable or an already existing macro: ((i PList Compiler i))
will raise an error in that case. But it is possible to define a macro with
the same name as a predefined variable, like ((i __YEAR__ i)) for instance:
the result will be a ((i redefinition i)) of the predefined internal
variable ((i __YEAR__ i)). ((i PList Compiler i)) will just emit a warning
to notify about this situation.

((li it is not possible to undefine a predefined variable with ((i #undef i)).
((i PList Compiler i)) raises an error in that case.

lo))

!! !! ((|
!! !!     #ifdef INFOPLIST_PATH
!! !!         #warning "Info.plist is located in " __INFOPLIST_PATH__
!! !!     #endif
!! !! |))


((s2 Unsupported variables

A few predefined variables available in the CodeWarrior property list 
compiler are not supported by ((b PList Compiler b)). This is mainly because they 
are specific to the CodeWarrior IDE and have no meaning with Xcode. Here 
is the list of these variables:
((|
    __APPLEMACHLINKER__, __MACH__, __MERGELINKER__, 
    __MWMACHLINKER__, __MWPEFLINKER__
|))

The ((v __LINE__ v)) variable is not supported either, as well as the 
((v __IDE_TARGET__() v)) and ((v __STRING__() v)) pseudo-macros.


((s1 Unicode characters

By default, ((b PList Compiler b)) assumes that the input file is UTF-8 encoded 
and it generates its output files in the same encoding. So there is no 
problem for supporting any Unicode character in your plc source files: you 
just have to use a text editor which handles the UTF-8 encoding form.
If you prefer editing your plc source files in macRoman, all you have to 
do is to specify this to the ((i plcompile i)) script using the ((i -input_encoding i)) 
option. 

Alternatively, if you just need occasionnally to use Unicode characters,
you can also embed them in strings using the ((v \u v)) escape sequence:
each Unicode character can be designated using the sequence ((v \u v))
followed by the code-point of the character in hexadecimal. For instance,
the Unicode code-points for the lowercase letters of the greek alphabet
start at 03B1:
((t1
((tr ((i Code-point i))	((i Letter i))
((tr 03B1	GREEK SMALL LETTER ALPHA
((tr 03B2	GREEK SMALL LETTER BETA
((tr 03B3	GREEK SMALL LETTER GAMMA
((tr 03B4	GREEK SMALL LETTER DELTA
((tr 03B5	GREEK SMALL LETTER EPSILON
((tr 03B6	GREEK SMALL LETTER ZETA
((tr 03B7	GREEK SMALL LETTER ETA
((tr 03B8	GREEK SMALL LETTER THETA
((tr 03B9	GREEK SMALL LETTER IOTA
t))
A string can thus be defined like this
((|
    key "UniString1" value string "\u03B1 \u03B2 \u03B3 \u03B4 \u03B5 \u03B6 \u03B7 \u03B8 \u03B9"
|))
!! !! ===================================
((if $aida_target eq "Html" || $aida_target eq "SplitHtml"
!! !! ===================================
and will produce:
!! !! ((im Images/plc_greekletters.jpg
!! !! String with greek letters im))
((q 
((nl <key>UniString1</key>
((nl <string>&#945;&nbsp;&#946;&nbsp;&#947;&nbsp;&#948;&nbsp;&#949;&nbsp;&#950;&nbsp;&#951;&nbsp;&#952;&nbsp;&#953;</string>
q))
!! !! ===================================
if))
!! !! ===================================

((b Note: b)) the escape sequence to designate Unicode characters is ((v \u v)) with a 
((i lowercase u i)). This is a difference with the CodeWarrior property
list compiler which used \U.


((a pkginfo )) a))
((s1 Pkginfo file

With the ((i -pkginfo i)) command line option, one can ask ((i PList
Compiler i)) to generate a ((i PkgInfo i)) file containing the type and
signature of the product. This file will be located in the same folder as
the ((i Info.plist i)) file. The type and signature are computed like this:
((lu
((li if ((v PKGINFO_SIGNATURE v)) and ((v PKGINFO_TYPE v)) preprocessor
macros have been defined in the ((i plc i)) file or in a prefix file, 
use them. Defining ((v PKGINFO_SIGNATURE v)) and ((v PKGINFO_TYPE v)) 
macros let you override any other setting.

((li otherwise, if the ((i CFBundleSignature i)) and ((i CFBundleType i))
keys have been specified in the ((i plc i)) file, use their value

((li otherwise, if the ((v MACOS_CREATOR v)) and ((v MACOS_TYPE v))
variables have been defined in Xcode and are not empty, use their value

((li as last resort, if the previous failed, use ((i "????" i))
lu))

If the type or the signature are shorter than four characters, they are
padded with blanks. On the contrary, if the string is longer than four
characters, it is trimmed.

((b Caveat: b))
in order to use the ((i -pkginfo i)) option, the ((i Force Package Info
Generation i)) setting in Xcode must be off. If it is on, ((i PList
Compiler i)) will raise an error and will not generate the ((i PkgInfo i))
file.


!! !! ===================================
((if $aida_target eq "Html" || $aida_target eq "SplitHtml"
!! !! ===================================
((a advanced )) a))
((s1 Advanced topics

Since ((b PList Compiler b)) is written in ((lk http://wiki.tcl.tk/ )) Tcl lk)), 
it is possible to introduce some Tcl code in the ((i #if i)) conditions.
One could for instance let an instruction depend on the existence of some
file like this:
((|
    #if "[file exists /path/to/some/file]"
       // do something. For instance include it!
        #include "/path/to/some/file"
    #endif
|))

The Tcl instruction must be written as a string (with double quotes) and 
should obviously return a boolean value (0 or 1). Anything which 
can be ((i eval i))'ed by the Tcl interpreter is acceptable, even sourcing an external Tcl 
script, provided it returns a boolean value. Here is a sample:
((|
    #if "[source [file join [pwd] script.tcl]]"
        // do something...
    #endif
|))


The Tcl instruction could also be built in several pieces to mix it with 
substitutable variables. For instance:
((|
    #define SOME_FILE  /path/to/some/file
    
    #if "[file exists " SOME_FILE "]"
        #warning "file exists: " SOME_FILE
    #else
        #warning "file does not exist: " SOME_FILE
    #endif
|))



((s1 Download
((b PList Compiler b)) is an ((i Open Source Project i)). Its source code
is freely available and can be found on the SourceForge site at the
following address:
((nl <http://sourceforge.net/projects/plistcompiler>

((nl PList Compiler releases are available at
((nl <http://sourceforge.net/project/showfiles.php?group_id=149940> 
((nl or on my web 
page at 
((nl <http://perso.orange.fr/bdesgraupes/DocHTML/plistcompiler.html>

((nl The code is under Subversion control. You can retrieve the latest stage of 
development using any Subversion client. See instructions at:
((nl <http://sourceforge.net/svn/?group_id=149940>

((nl You can browse the Subversion repository online at
((nl <http://plistcompiler.svn.sourceforge.net/viewvc/plistcompiler> 



((s1 Known problems
((nl Please e-mail any problem or bug you encounter:
((nl <bdesgraupes@users.sourceforge.net>
((nl Visit my Web page for updates and other recent builds:
((nl <http://perso.orange.fr/bdesgraupes/>
((nl Visit the PList Compiler project area on the SourceForge site:
((nl <http://sourceforge.net/projects/plistcompiler>

There is also a mailing list, ((b plistcompiler-users b)), for discussing any
topics related to the usage of PList Compiler and its future development. New 
versions will be announced on this list
too. You can subscribe or unsubscribe from the following address:
((nl <http://lists.sourceforge.net/mailman/listinfo/plistcompiler-users>
To post to this list, send mail to
<plistcompiler-users@lists.sourceforge.net>

!! !! ===================================
if))
!! !! ===================================

((s1 Version history
For a detailed list of the changes, see the file ((i Changes_PLC i)) in 
the Subversion repository.
((lu
((li 2005-10-10 - 0.1b1 - First public beta release. Basic implementation.
((li 2005-10-12 - 0.1b2 - Fixed bug when #including pathname with whitespace.
((li 2005-10-13 - 0.1b3 - Improved use of single quotes. Minor fixes. 
Unicode characters.
((li 2005-10-14 - 0.1rc1 - First release candidate.
((li 2005-11-03 - 0.1 - First final release. Added -version option.
((li 2005-11-23 - 0.2 - Support for Headers Search Paths in #include 
directives. Command line option to generate the PkgInfo file.
((li 2005-12-13 - 0.3 - Fixed bug when array keyword followed by opening 
bracket on the same line.
((li 2006-03-29 - 0.4 - Use TARGET_BUILD_DIR for output dir. Convert some 
symbols to correct XML entities. Fixed bug when HEADER_SEARCH_PATHS not 
defined in Xcode.
((li 2006-11-04 - 0.5 - Fixed issues with square brackets and double 
slashes in strings. Fixed bug with user defined macros enclosed in double 
underscores (Bug 1413845). Implements new -prefix option (RFE 1461559) and new 
-o option (patch 1474228). New pragma escape_entities.
((li 2006-11-12 - 0.5.1 - Improved generation of Pkginfo file.
((li 2007-09-07 - 0.6 - New -D option to define macros on the command line.
New -I option to add include paths. Support for line continuator. Sym links
resolution. Simplified and improved variable substitution. Minor fixes.
lu))


((s1 License and disclaimer

((b PList Compiler b)) is distributed under the same BSD License as
the Tcl language itself: see the file ((i License_terms i)) in the distribution or 
the ((lk http://www.opensource.org/licenses/bsd-license )) Open Source Initiative site. lk))




!! !! ===================================
((if $aida_target eq "Html"
!! !! ===================================

((-
((nl Last updated ((s [ISOTime::ISODateAndTimeRelaxed] s))
!! logo SF
!! -------
((-
((nl ((i PList Compiler is hosted by i)) 
((lk http://sourceforge.net )) ((im http://sourceforge.net/sflogo.php?group_id=149940&amp;type=4 
SourceForge.net Logo im)) lk))

!! !! ===================================
if))
!! !! ===================================
